---
title: "CHURP: Bulk RNAseq Pipeline Summary"
output:
    html_document:
        smart: false
        theme: cerulean
        toc: true
        toc_depth: 3
        toc_float:
            collapsed: false
        number_sections: true
        df_print: paged
date: "`r format(Sys.time(), '%Y-%m-%d, %T')`"
params:
    pipeline: NA
    samplesheet: NA
    outdir: NA
    workdir: NA
---

```{r exportvars, echo=FALSE, message=FALSE}
for(key in names(params)) {
    do.call("Sys.setenv", params[key])
}

# Read in the data sets here so that we don't have to keep doing it later
read_summary <- read.table(paste(params["workdir"], "allsamples", "Read_Counts.txt", sep="/"), header=F)
# Set NAs in read summary to 0
read_summary[is.na(read_summary)] <- 0
sheet <- read.table(as.character(params["samplesheet"]), sep="|", header=FALSE, comment.char="#", stringsAsFactors=FALSE)
samplenames <- sheet$V1
nsamp <- length(samplenames)
hisat_summary <- read.table(paste(params["workdir"], "allsamples", "HISAT_Stats.txt", sep="/"), header=F)
names(hisat_summary) <- c("SampleName", "Total", "Unmapped", "UniqueMapped", "MultiMapped", "DiscoMapped")
dup_summary <- read.table(paste(params["workdir"], "allsamples", "Dup_Stats.txt", sep="/"), header=F)
names(dup_summary) <- c("SampleName", "R1_Dup", "R2_Dup")
bbduk_summary <- read.table(paste(params["workdir"], "allsamples", "rRNA_kmers.txt", sep="/"), header=F)
names(bbduk_summary) <- c("SampleName", "rRNA_Fragments", "rRNA_Pct")
picard_rnaseq_summary <- read.table(paste(params["workdir"], "allsamples", "RNASeq_Metrics.txt", sep="/"), header=F)
names(picard_rnaseq_summary) <- c(
    "SampleName",
    "RIBOSOMAL_BASES", "CODING_BASES", "UTR_BASES", "INTRONIC_BASES", "INTERGENIC_BASES",
    "CORRECT_STRAND_READS", "PCT_RIBOSOMAL_BASES", "PCT_CODING_BASES", "PCT_UTR_BASES",
    "PCT_INTRONIC_BASES", "PCT_INTERGENIC_BASES", "PCT_USABLE_BASES", "PCT_CORRECT_STRAND_READS")
```

CHURP was developed by the Research Informatics Solutions (RIS) group at MSI
with funding provided by the University of Minnesota Informatics Institute
(UMII).

<https://www.msi.umn.edu/>

<https://research.umn.edu/units/umii>

# Key Figures and Summaries
## Experiment Summary
A tabular summary of the samples and reads that were analyzed is shown below:

```{r samplesheet_sum, echo=FALSE, message=FALSE}
library(knitr)
# Define an NA-robust function here
base_na <- function(x) {
    if(is.na(x)) {
        return("NA")
    } else {
        return(basename(x))
    }
}
# Change the full R1/R2 paths into basenames
sheet$V3 <- as.character(sapply(sheet$V3, base_na))
sheet$V4 <- as.character(sapply(sheet$V4, base_na))
# And the reference, too
# Keep only sample name, group, R1, R2, Trim, rmdup, Trim opts, unstranded
sumsheet <- sheet[,c(1, 2, 3, 4, 7, 8, 9, 12)]
# Make the names nice
names(sumsheet) <- c(
    "Sample Name",
    "Group",
    "R1",
    "R2",
    "Trim?",
    "Remove Dups?",
    "Trim Options",
    "Strand")
sumsheet
```

## Fragment Counts Plot
```{r counts_sum, echo=FALSE, message=FALSE}
read_dat <- matrix(
    c(read_summary$V2, read_summary$V4)/1000000,
    byrow=FALSE,
    nrow=nrow(read_summary)
    )
max_reads <- max(read_dat)
at <- barplot(
    t(read_dat),
    beside=TRUE,
    ylim=c(0, max_reads*1.15),
    axes=FALSE,
    col=c("#d95f02", "#1b9e77"),
    ylab="Fragment Count (Millions)",
    main="Fragment Counts")
legend("top", c("Raw", "Trimmed"), fill=c("#d95f02", "#1b9e77"), ncol=2)
axis(side=2)
axis(side=1, at=apply(at, 2, mean), labels=as.character(read_summary$V1), cex.axis=0.6, las=2)
```

## Read Quality Plots {.tabset}
### Raw Reads

```{r raw_qual_sum, echo=FALSE, message=FALSE, fig.width=8, fig.height=0.7*nrow(sheet)}
plotqual_first <- function(sn) {
    allquals <- matrix(0:45)
    image(
        allquals,
        breaks=c(0, 10, 20, 25, 30, 40, 45),
        col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
        axes=FALSE,
        main="Quality Key")
    axis(side=1, at=seq(0, 1, length.out=46)[c(TRUE, FALSE)], labels=as.character(0:45)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)

    plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
    qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R1_raw_quals.txt", sep=""), sep="/")
    dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
    names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
    # Make a plot
    image(
        as.matrix(dat$QMean),
        breaks=c(0, 10, 20, 25, 30, 40, 45),
        col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
        axes=FALSE,
        main="Mean R1 Quality")
    mtext(side=2, font=2, cex=0.5, las=2, sn)
    qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R2_raw_quals.txt", sep=""), sep="/")
    if(!file.exists(qr2_file)) {
        plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
        text(x=0.5, y=0.5, "No R2", cex=1, col="black")
    } else{
        dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE,
            main="Mean R2 Quality")
    }
}

plotqual <- function(sn) {
    qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R1_raw_quals.txt", sep=""), sep="/")
    dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
    names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
    # Make a plot
    image(
        as.matrix(dat$QMean),
        breaks=c(0, 10, 20, 25, 30, 40, 45),
        col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
        axes=FALSE)
    mtext(side=2, font=2, cex=0.5, las=2, sn)
    qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R2_raw_quals.txt", sep=""), sep="/")
    if(!file.exists(qr2_file)) {
        plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
        text(x=0.5, y=0.5, "No R2", cex=1, col="black")
    } else{
        dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE)
    }
}

plotqual_last <- function(sn) {
    qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R1_raw_quals.txt", sep=""), sep="/")
    dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
    names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
    # Make a plot
    image(
        as.matrix(dat$QMean),
        breaks=c(0, 10, 20, 25, 30, 40, 45),
        col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
        axes=FALSE)
    mtext(side=2, font=2, cex=0.5, las=2, sn)
    axis(side=1, at=seq(0, 1, length.out=nrow(dat))[c(TRUE, FALSE)], labels=as.character(dat$Base)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)
    qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R2_raw_quals.txt", sep=""), sep="/")
    if(!file.exists(qr2_file)) {
        plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
        text(x=0.5, y=0.5, "No R2", cex=1, col="black")
    } else{
        dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
        dat$X <- 1:nrow(dat)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE)
        axis(side=1, at=seq(0, 1, length.out=nrow(dat))[c(TRUE, FALSE)], labels=as.character(dat$Base)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)
    }
}
par(mfrow=c(nsamp+1, 2))
# Set the margins of the top to be high on the first two so we can add the R1/R2 labels
par(mar=c(1.1, 5, 1.1, 0.1), mgp=c(1.25, 0.15, 0))
dummy <- plotqual_first(samplenames[1])
par(mar=c(1.1, 5, 1.1, 0.1))
dummy <- sapply(samplenames[3:nsamp-1], plotqual)
par(mar=c(2.5, 5, 0.1, 0.1), mgp=c(1.25, 0.15, 0))
dummy <- plotqual_last(samplenames[nsamp])
```

### Trimmed Reads
```{r trim_qual_sum, echo=FALSE, message=FALSE, fig.width=8, fig.height=0.7*nrow(sheet)}
trim_samp <- sheet$V1[sheet$V7 == "yes"]
if(length(trim_samp) > 0) {
    plotqual_first <- function(sn) {
        allquals <- matrix(0:45)
        image(
            allquals,
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE,
            main="Quality Key")
        axis(side=1, at=seq(0, 1, length.out=46)[c(TRUE, FALSE)], labels=as.character(0:45)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)

        plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
        qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R1_trim_quals.txt", sep=""), sep="/")
        dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        # Make a plot
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE,
            main="Mean R1 Quality")
        mtext(side=2, font=2, cex=0.5, las=2, sn)
        qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R2_trim_quals.txt", sep=""), sep="/")
        if(!file.exists(qr2_file)) {
            plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
            text(x=0.5, y=0.5, "No R2", cex=1, col="black")
        } else{
            dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
            names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
            image(
                as.matrix(dat$QMean),
                breaks=c(0, 10, 20, 25, 30, 40, 45),
                col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
                axes=FALSE,
                main="Mean R2 Quality")
        }
    }

    plotqual <- function(sn) {
        qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R1_trim_quals.txt", sep=""), sep="/")
        dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        # Make a plot
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE)
        mtext(side=2, font=2, cex=0.5, las=2, sn)
        qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R2_trim_quals.txt", sep=""), sep="/")
        if(!file.exists(qr2_file)) {
            plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
            text(x=0.5, y=0.5, "No R2", cex=1, col="black")
        } else{
            dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
            names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
            image(
                as.matrix(dat$QMean),
                breaks=c(0, 10, 20, 25, 30, 40, 45),
                col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
                axes=FALSE)
        }
    }

    plotqual_last <- function(sn) {
        qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R1_trim_quals.txt", sep=""), sep="/")
        dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        # Make a plot
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE)
        mtext(side=2, font=2, cex=0.5, las=2, sn)
        axis(side=1, at=seq(0, 1, length.out=nrow(dat))[c(TRUE, FALSE)], labels=as.character(dat$Base)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)
        qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R2_trim_quals.txt", sep=""), sep="/")
        if(!file.exists(qr2_file)) {
            plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
            text(x=0.5, y=0.5, "No R2", cex=1, col="black")
        } else{
            dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
            dat$X <- 1:nrow(dat)
            names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
            image(
                as.matrix(dat$QMean),
                breaks=c(0, 10, 20, 25, 30, 40, 45),
                col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
                axes=FALSE)
            axis(side=1, at=seq(0, 1, length.out=nrow(dat))[c(TRUE, FALSE)], labels=as.character(dat$Base)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)
        }
    }
    nsamp <- length(trim_samp)
    par(mfrow=c(nsamp+1, 2))
    # Set the margins of the top to be high on the first two so we can add the R1/R2 labels
    par(mar=c(1.1, 5, 1.1, 0.1), mgp=c(1.25, 0.15, 0))
    dummy <- plotqual_first(trim_samp[1])
    par(mar=c(1.1, 5, 1.1, 0.1))
    dummy <- sapply(trim_samp[3:nsamp-1], plotqual)
    par(mar=c(2.5, 5, 0.1, 0.1), mgp=c(1.25, 0.15, 0))
    dummy <- plotqual_last(trim_samp[nsamp])
    } else {
        print("No trimming performed.")
    }
```

## HISAT2 Plots {.tabset}
### Counts
```{r hisat2_counts_sum, echo=FALSE, message=FALSE}
count_dat <- as.matrix(hisat_summary[,c("UniqueMapped", "MultiMapped", "DiscoMapped", "Unmapped")])
max_reads <- max(hisat_summary$Total)/1000000
at <- barplot(
    t(count_dat)/1000000,
    beside=FALSE,
    col=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
    ylim=c(0, max_reads*1.15),
    ylab="Fragment Count (Millions)",
    main="HISAT2 Count Plot",
    axes=FALSE)
axis(side=2)
axis(side=1, at=at, labels=as.character(hisat_summary$SampleName), cex.axis=0.6, las=2)
legend(
    "top",
    c("Uniquely Mapped", "Multiply Mapped", "Discordantly Mapped", "Unmapped"),
    fill=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
    ncol=4,
    cex=0.7)
```

### Proportions
```{r hisat2_prop_sum, echo=FALSE, message=FALSE}
count_dat <- as.matrix(hisat_summary[,c("UniqueMapped", "MultiMapped", "DiscoMapped", "Unmapped")])
# Then make a proportion plot
prop_dat <- count_dat / hisat_summary$Total
barplot(
    t(prop_dat),
    beside=FALSE,
    col=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
    ylim=c(0, 1.15),
    ylab="Fraction",
    main="HISAT2 Proportion Plot",
    axes=FALSE)
legend(
    "top",
    c("Uniquely Mapped", "Multiply Mapped", "Discordantly Mapped", "Unmapped"),
    fill=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
    ncol=4,
    cex=0.7)
axis(side=2)
axis(side=1, at=at, labels=as.character(hisat_summary$SampleName), cex.axis=0.6, las=2)
```

## Expression Plots {.tabset}
### Expressed Genes
```{r expressed_sum, echo=FALSE, message=FALSE}
subread_counts <- read.table(paste(params["workdir"], "allsamples", "subread_counts.txt", sep="/"), header=T, sep="\t", comment.char="#")
subread_counts <- subread_counts[,-c(1:6)]
num_expressed <- as.numeric(apply(subread_counts, 2, function(x) sum(x>0)))
maxexpr <- max(num_expressed)
at <- barplot(
    num_expressed,
    ylab="Number of Expressed Features",
    ylim=c(0, maxexpr*1.15),
    col="#1f78b4",
    axes=FALSE)
axis(side=2)
axis(side=1, at=at, labels=names(subread_counts), las=2, cex.axis=0.7)
```

### CPM

```{r cpm_sum, echo=FALSE, message=FALSE, out.width="800", out.height="800"}
library(knitr)
cpm_plot <- paste(params["outdir"], "Plots", "cpm_plot.pdf", sep="/")
include_graphics(cpm_plot)
```

### Clustering Heatmap

```{r hmp_sum, echo=FALSE, message=FALSE, out.width="800", out.height="800"}
library(knitr)
heatmap_plot <- paste(params["outdir"], "Plots", "high_variance_heatmap.pdf", sep="/")
include_graphics(heatmap_plot)
```

### MDS

```{r mds_sum, echo=FALSE, message=FALSE, out.width="800", out.height="800"}
library(knitr)
mds_plot <- paste(params["outdir"], "Plots", "mds_plot.pdf", sep="/")
include_graphics(mds_plot)
```

## DEG Summary
```{r deg_overview, echo=FALSE, message=FALSE, results="asis"}
library(knitr)
degdir <- paste(params["outdir"], "DEGs", sep="/")
if(!dir.exists(degdir)) {
    print("There were no groups defined, so there are no differentially expressed genes.")
} else {
    deg_files <- list.files(degdir, full.names=TRUE)
    if(length(deg_files) == 0) {
        print("There were no groups defined, so there are no differentially expressed genes.")
    } else {
        gene_names <- read.table(paste(params["outdir"], "gene_id_gene_name_map.txt", sep="/"), header=FALSE)
        names(gene_names) <- c("EnsemblID", "GeneName")
        for(i in 1:length(deg_files)) {
            curr_f <- deg_files[i]
            fname <- basename(curr_f)
            gps <- unlist(strsplit(fname, "_"))[2]
            d <- read.table(curr_f, header=TRUE)
            d_g <- merge(d, gene_names, by.x="genes", by.y="EnsemblID")
            d_g <- d_g[order(d_g$FDR),]
            if(nrow(d_g) < 10) {
                lim <- nrow(d_g)
            } else {
                lim <- 10
            }
            print(kable(d_g[1:lim,], caption=paste("Top 10 DEGs at the 0.05 FDR for ", gps, sep="")))
        }
    }
}
```

# Run Summary
## General Workflow
Raw reads from individual samples are summarized with FastQC. If the `--no-trim`
option was specified (see samplesheet, below), then raw reads are aligned to the
reference genome with HISAT2. If `--no-trim` was not specified, then the reads
are cleaned with Trimmomatic and re-assessed with FastQC, and trimmed reads are
aligned to the reference genome with HISAT2. Reads aligning to genes are counted
with featureCounts, from the subread package. Raw counts are transformed into
counts-per-million with the edgeR package. Genes that are shorter than the
specified minimum length (`--min-len` argument, default 200bp) are pruned from
the counts matrix before any differential expression analysis. If experimental
groups were supplied, then differential expression analysis is performed with a
quasi-likelihood test in edgeR, with a 0.05 false discovery rate correction
applied.

## Results and Intermediate Files
### Output Directory
The output directory is located at

``r params["outdir"]``

This directory contains final results files and log files for the pipeline. Be
sure to save these files if you would like to keep them. However, the pipeline
script and samplesheet (reproduced below) are sufficient to recreate all output
files. It will just require additional compute time and service units. The
following directories are of interest:

- ``r paste(params["outdir"], "Counts", sep="/")``

    Contains raw and CPM-transformed counts for each gene in the supplied GTF
    annotation.

- ``r paste(params["outdir"], "DEGs", sep="/")``

    Contains a list of significantly differentially expressed genes, if
    experimental groups were supplied. If differential expression analysis was
    conducted, but no genes passed thresholds for significance, then the files
    will only have a header. Pairwise combinations of groups are tested for
    significance, so this directory may contain multiple files.

- ``r paste(params["outdir"], "InsertSizeMetrics", sep="/")``

    Contains per-sample insert size summaries from Picard tools. The mean,
    median, and standard deviation are summarized in a table in the "Alignment
    Summaries" section of this report.

- ``r paste(params["outdir"], "Logs", sep="/")``

    Contains per-sample run logs for read QC, trimming, and alignment. Also
    contains a log file for counting reads and performing differential
    expression testing.

- ``r paste(params["outdir"], "Plots", sep="/")``

    Contains PDF vector images of expression summary plots. The plots are also
    embedded into the "Counts Summaries" subsection of the "Alignment Summaries"
    section of this report.

### Work Directory
The work directory is located at

``r params["workdir"]``

This directory contains intermediate files for the pipeline. Be sure to save
these files if you would like to refer to them in the future. However, the
pipeline script and samplesheet (reproduced below) are sufficient to recreate
all intermediate files for the pipeline. The work directory contains the
following:

- ``r paste(params["workdir"], "allsamples", sep="/")``

    Summary files used to generate this report and final BAM files used for
    generating raw counts.

- ``r paste(params["workdir"], "singlesamples", sep="/")``

    Sub-directories, one for each sample, with FastQC reports, trimmed reads,
    intermediate SAM and BAM files, and alignment summary files. Refer to these
    if you would like to see the details of one particular sample. For example,
    if one sample has unexpected expression values, it may be because the
    sample is of low quality; this would be apparent in the read quality reports
    and the alignment summaries that are found in its work directory.

## Pipeline Script
The path to the pipeline script is ``r params["pipeline"]``

The pipeline script is printed below. You may copy and paste the following
script into a new plain text document to recreate the analyses run here. Be sure
to save it with UNIX line endings (`LF` rather than `CR` [Mac] or `CRLF`
[Windows] line endings), or else it will cause errors on Mesabi. Also be sure to
turn off "smart quotes" and "smart dashes" on any text editors that you use to
paste the following script. Smart quotes and smart dashes are not interpreted
correctly by the shell on Mesabi and will also cause errors.

<details><summary>

**Click to show pipeline script**

</summary>
```{bash pipeline_script, echo=FALSE, comment=NA}
cat $pipeline
```
</details>

## Samplesheet
The path to the samplesheet is ``r params["samplesheet"]``

The samplesheet is printed below, verbatim. It is cumbersome to read, but you
may copy and paste it into a plain text document to recreate the analyses run
here. Like the pipeline script, be sure to save it with UNIX line endings
(`LF` rather than `CR` [Mac] or `CRLF` [Windows]). Be sure to disable "smart
quotes" and "smart dashes" on the text editor.

<details><summary>

**Click to show samplesheet**

</summary>

```{bash samplesheet, echo=FALSE, comment=NA}
cat $samplesheet
```

</details>

The raw samplesheet is difficult to read, so we will print out a readable
summary below:

```{r samplesheet_readable, echo=FALSE, message=FALSE}
library(knitr)
# Define an NA-robust function here
base_na <- function(x) {
    if(is.na(x)) {
        return("NA")
    } else {
        return(basename(x))
    }
}
# Change the full R1/R2 paths into basenames
sheet$V3 <- as.character(sapply(sheet$V3, base_na))
sheet$V4 <- as.character(sapply(sheet$V4, base_na))
# And the reference, too
sheet$V10 <- as.character(sapply(sheet$V10, base_na))
sheet$V13 <- as.character(sapply(sheet$V13, base_na))
# Drop the output and work directories, columns 5 and 6
sheet <- sheet[,-c(5, 6)]
# Make the names nice
names(sheet) <- c(
    "Sample Name",
    "Group",
    "R1",
    "R2",
    "Trim?",
    "Remove Dups?",
    "Trimmomatic Options",
    "Reference Genome",
    "HISAT2 Options",
    "Strand",
    "GTF Name")
sheet
```

## Software Environment {.tabset}
### Single Sample Job Modules
This is the full list of loaded modules for each single-sample job, which
includes read trimming and read mapping.

```{bash single_sample_modules, echo=FALSE, comment=NA}
first_sample=$(head -n 1 $samplesheet | cut -f 1 -d '|')
log_name="${outdir}/Logs/${first_sample}_Log.txt"
log_start=$(($(grep -n '^#BEGIN_MODULE' "${log_name}" | cut -f 1 -d ':') + 2))
log_end=$(($(grep -n '^#END_MODULES' "${log_name}" | cut -f 1 -d ':') - 1))
head -n "${log_end}" "${log_name}" | tail -n "+${log_start}"
```
### Summary Job Modules
This is the full list of loaded modules for the summary job, which includes
counting and differential expression testing.

```{bash summary_modules, echo=FALSE, comment=NA}
log_name="${outdir}/Logs/BulkRNASeq_Summary_Log.txt"
log_start=$(($(grep -n '^#BEGIN_MODULES' "${log_name}" | cut -f 1 -d ':') + 2))
log_end=$(($(grep -n '^#END_MODULES' "${log_name}" | cut -f 1 -d ':') - 1))
head -n "${log_end}" "${log_name}" | tail -n "+${log_start}"
```

# QC Metrics
## Read Counts
```{r read_counts, echo=FALSE, message=FALSE}
library(knitr)
names(read_summary) <- c(
    "Sample Name",
    "Raw R1 Count",
    "Raw R2 Count",
    "Trimmed R1 Count",
    "Trimmed R2 Count")
kable(read_summary, caption="Read count summary.")
```

## rRNA Contamination (Based on Kmer Matching) {.tabset}
These counts were based on searching a subset of the raw reads against a
reference database of ribosomal K-mers. Click on the table headers to show the
summaries of rRNA contamination.

### Plot
```{r bbduk_plot, echo=FALSE, message=FALSE}
plt_dat <- as.numeric(bbduk_summary$rRNA_Pct)
at <- barplot(
    plt_dat,
    col="#e41a1c",
    ylim=c(0, 110),
    xlab="",
    ylab="Percent rRNA",
    main="K-mer Based rRNA Contamination",
    axes=F)
axis(side=1, at=at, labels=as.character(bbduk_summary$SampleName), las=2, cex.axis=0.6)
axis(side=2, at=seq(0, 100, by=10), labels=seq(0, 100, by=10))
rect(
    xleft=par("usr")[1],
    xright=par("usr")[2],
    ybottom=20,
    ytop=35,
    col=rgb(255/255, 237/255, 160/255, 0.5),
    border=NA
    )
rect(
    xleft=par("usr")[1],
    xright=par("usr")[2],
    ybottom=35,
    ytop=100,
    col=rgb(228/255, 26/255, 28/255, 0.25),
    border=NA
    )
```

### Table
```{r bbduk_table, echo=FALSE, message=FALSE}
library(knitr)
kable(bbduk_summary, caption="Number of read pairs and percentage of library that is estimated to be derived from ribosomal RNA.")
```

## Sequence Duplication {.tabset}
These plots show sequence duplication summaries, derived from FastQC output.
Click on the tab headers to show the various summaries.

### Overall Duplication
```{r dup_overall, echo=FALSE, message=FALSE}
plt_dat <- matrix(as.numeric(c(dup_summary$R1_Dup, dup_summary$R2_Dup)), nrow=2, byrow=TRUE)
at <- barplot(
    plt_dat,
    beside=TRUE,
    axes=F,
    col=c("#d95f02", "#1b9e77"),
    ylim=c(0, 110),
    xlab="",
    ylab="Percent Duplicated",
    main="Total Duplication")
axis(side=1, at=apply(at, 2, mean), labels=as.character(dup_summary$SampleName), las=2, cex.axis=0.6)
axis(side=2, at=seq(0, 100, by=10), labels=seq(0, 100, by=10))
legend("topright", c("R1", "R2"), fill=c("#d95f02", "#1b9e77"))
```

### Duplication Histograms
```{r dup_hist, echo=FALSE, message=FALSE, fig.width=8, fig.height=1.75*nrow(sheet)}
par(mfrow=c(nrow(sheet), 2), mar=c(4, 3.5, 1, 0), mgp=c(2.5, 0.75, 0))
plot_dup <- function(sn) {
    r1_dfile <- paste(params["outdir"], "Dup_Stats", paste(sn, "_R1_Dups.txt", sep=""), sep="/")
    r1_dup <- read.table(r1_dfile, header=FALSE, stringsAsFactors=FALSE)
    plt_dat <- as.matrix(r1_dfile[, c("V2", "V3")])
    at <- barplot(
        t(plt_dat),
        axes=F,
        beside=TRUE,
        col=c("#a6cee3", "#1f78b4"),
        ylim=c(0, 110),
        xlab="Duplication Level",
        ylab="Percentage",
        main=paste("Duplication in ", sn, " R1", sep=""))
    axis(side=1, at=apply(at, 2, mean), labels=as.character(plt_dat$V1), las=2, cex.axis=0.6)
    axis(side=2, at=seq(0, 100, by=10), labels=seq(0, 100, by=10))
    legend("topright", c("Of Deduplicated", "Of Total"), fill=c("#a6cee3", "#1f78b4"))
    r2_dfile <- paste(params["outdir"], "Dup_Stats", paste(sn, "_R2_Dups.txt", sep=""), sep="/")
    if(!file.exists(r2_dfile)) {
            plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
            text(x=0.5, y=0.5, "No R2 file found.", cex=1.5, col="black")
        } else {
            r2_dup <- read.table(r2_dfile, header=FALSE, stringsAsFactors=FALSE)
            plt_dat <- as.matrix(r2_dfile[, c("V2", "V3")])
            at <- barplot(
                t(plt_dat),
                axes=F,
                beside=TRUE,
                col=c("#a6cee3", "#1f78b4"),
                ylim=c(0, 110),
                xlab="Duplication Level",
                ylab="Percentage",
                main=paste("Duplication in ", sn, " R2", sep=""))
            axis(side=1, at=apply(at, 2, mean), labels=as.character(plt_dat$V1), las=2, cex.axis=0.6)
            axis(side=2, at=seq(0, 100, by=10), labels=seq(0, 100, by=10))
            legend("topright", c("Of Deduplicated", "Of Total"), fill=c("#a6cee3", "#1f78b4"))
    }
}
sapply(samplenames, plot_dup)
```

## Read Qualities {.tabset}
Click on the tab headers to show plots of raw and trimmed read qualities.

### Raw Read Qualities (Compact style)
These plots show the read qualities as they came off the sequencing instrument.
```{r raw_read_quals, echo=FALSE, message=FALSE, fig.width=8, fig.height=0.7*nrow(sheet)}
plotqual_first <- function(sn) {
    allquals <- matrix(0:45)
    image(
        allquals,
        breaks=c(0, 10, 20, 25, 30, 40, 45),
        col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
        axes=FALSE,
        main="Quality Key")
    axis(side=1, at=seq(0, 1, length.out=46)[c(TRUE, FALSE)], labels=as.character(0:45)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)

    plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
    qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R1_raw_quals.txt", sep=""), sep="/")
    dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
    names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
    # Make a plot
    image(
        as.matrix(dat$QMean),
        breaks=c(0, 10, 20, 25, 30, 40, 45),
        col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
        axes=FALSE,
        main="Mean R1 Quality")
    mtext(side=2, font=2, cex=0.5, las=2, sn)
    qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R2_raw_quals.txt", sep=""), sep="/")
    if(!file.exists(qr2_file)) {
        plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
        text(x=0.5, y=0.5, "No R2", cex=1, col="black")
    } else{
        dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE,
            main="Mean R2 Quality")
    }
}

plotqual <- function(sn) {
    qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R1_raw_quals.txt", sep=""), sep="/")
    dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
    names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
    # Make a plot
    image(
        as.matrix(dat$QMean),
        breaks=c(0, 10, 20, 25, 30, 40, 45),
        col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
        axes=FALSE)
    mtext(side=2, font=2, cex=0.5, las=2, sn)
    qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R2_raw_quals.txt", sep=""), sep="/")
    if(!file.exists(qr2_file)) {
        plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
        text(x=0.5, y=0.5, "No R2", cex=1, col="black")
    } else{
        dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE)
    }
}

plotqual_last <- function(sn) {
    qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R1_raw_quals.txt", sep=""), sep="/")
    dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
    names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
    # Make a plot
    image(
        as.matrix(dat$QMean),
        breaks=c(0, 10, 20, 25, 30, 40, 45),
        col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
        axes=FALSE)
    mtext(side=2, font=2, cex=0.5, las=2, sn)
    axis(side=1, at=seq(0, 1, length.out=nrow(dat))[c(TRUE, FALSE)], labels=as.character(dat$Base)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)
    qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R2_raw_quals.txt", sep=""), sep="/")
    if(!file.exists(qr2_file)) {
        plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
        text(x=0.5, y=0.5, "No R2", cex=1, col="black")
    } else{
        dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
        dat$X <- 1:nrow(dat)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE)
        axis(side=1, at=seq(0, 1, length.out=nrow(dat))[c(TRUE, FALSE)], labels=as.character(dat$Base)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)
    }
}
par(mfrow=c(nsamp+1, 2))
# Set the margins of the top to be high on the first two so we can add the R1/R2 labels
par(mar=c(1.1, 5, 1.1, 0.1), mgp=c(1.25, 0.15, 0))
dummy <- plotqual_first(samplenames[1])
par(mar=c(1.1, 5, 1.1, 0.1))
dummy <- sapply(samplenames[3:nsamp-1], plotqual)
par(mar=c(2.5, 5, 0.1, 0.1), mgp=c(1.25, 0.15, 0))
dummy <- plotqual_last(samplenames[nsamp])
```

### Trimmed Read Qualities (Compact style)
These plots show read qualities post-trimming, if it was performed.
```{r trim_read_quals, echo=FALSE, message=FALSE, fig.width=8, fig.height=0.7*nrow(sheet)}
if(length(trim_samp) > 0) {
    plotqual_first <- function(sn) {
        allquals <- matrix(0:45)
        image(
            allquals,
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE,
            main="Quality Key")
        axis(side=1, at=seq(0, 1, length.out=46)[c(TRUE, FALSE)], labels=as.character(0:45)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)

        plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
        qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R1_trim_quals.txt", sep=""), sep="/")
        dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        # Make a plot
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE,
            main="Mean R1 Quality")
        mtext(side=2, font=2, cex=0.5, las=2, sn)
        qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R2_trim_quals.txt", sep=""), sep="/")
        if(!file.exists(qr2_file)) {
            plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
            text(x=0.5, y=0.5, "No R2", cex=1, col="black")
        } else{
            dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
            names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
            image(
                as.matrix(dat$QMean),
                breaks=c(0, 10, 20, 25, 30, 40, 45),
                col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
                axes=FALSE,
                main="Mean R2 Quality")
        }
    }

    plotqual <- function(sn) {
        qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R1_trim_quals.txt", sep=""), sep="/")
        dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        # Make a plot
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE)
        mtext(side=2, font=2, cex=0.5, las=2, sn)
        qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R2_trim_quals.txt", sep=""), sep="/")
        if(!file.exists(qr2_file)) {
            plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
            text(x=0.5, y=0.5, "No R2", cex=1, col="black")
        } else{
            dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
            names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
            image(
                as.matrix(dat$QMean),
                breaks=c(0, 10, 20, 25, 30, 40, 45),
                col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
                axes=FALSE)
        }
    }

    plotqual_last <- function(sn) {
        qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R1_trim_quals.txt", sep=""), sep="/")
        dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        # Make a plot
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE)
        mtext(side=2, font=2, cex=0.5, las=2, sn)
        axis(side=1, at=seq(0, 1, length.out=nrow(dat))[c(TRUE, FALSE)], labels=as.character(dat$Base)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)
        qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R2_trim_quals.txt", sep=""), sep="/")
        if(!file.exists(qr2_file)) {
            plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
            text(x=0.5, y=0.5, "No R2", cex=1, col="black")
        } else{
            dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
            dat$X <- 1:nrow(dat)
            names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
            image(
                as.matrix(dat$QMean),
                breaks=c(0, 10, 20, 25, 30, 40, 45),
                col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
                axes=FALSE)
            axis(side=1, at=seq(0, 1, length.out=nrow(dat))[c(TRUE, FALSE)], labels=as.character(dat$Base)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)
        }
    }
    nsamp <- length(trim_samp)
    par(mfrow=c(nsamp+1, 2))
    # Set the margins of the top to be high on the first two so we can add the R1/R2 labels
    par(mar=c(1.1, 5, 1.1, 0.1), mgp=c(1.25, 0.15, 0))
    dummy <- plotqual_first(trim_samp[1])
    par(mar=c(1.1, 5, 1.1, 0.1))
    dummy <- sapply(trim_samp[3:nsamp-1], plotqual)
    par(mar=c(2.5, 5, 0.1, 0.1), mgp=c(1.25, 0.15, 0))
    dummy <- plotqual_last(trim_samp[nsamp])
    } else {
        print("No trimming performed.")
    }
```

### Raw Read Qualities (FastQC-style)
The plots below show the variance in quality across the reads for each sample.
The black dot shows the mean quality, the red dot shows the median quality,
the grey shaded region shows the inter-quartile range, and the vertical black
lines show the 10th-90th percentile range.

```{r raw_read_quals_fastqc, echo=FALSE, message=FALSE, fig.width=8, fig.height=1.75*nrow(sheet)}
plotqual <- function(sn) {
    qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R1_raw_quals.txt", sep=""), sep="/")
    dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
    names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
    # Make a dummy variable for position because some of the classes are binned
    dat$X <- 1:nrow(dat)
    # Make a plot
    plot(dat$QMean ~ dat$X, type="n", xlab="Position in Read", ylab="Quality", axes=F, ylim=c(0, 45))
    segments(x0=dat$X, y1=dat$Q10, y0=dat$Q90, lwd=1, col="black")
    segments(x0=dat$X, y1=dat$Q25, y0=dat$Q75, lwd=8, col="grey")
    points(dat$QMean ~ dat$X, pch=19, col="black", cex=0.75)
    points(dat$QMedian ~ dat$X, pch=19, col="red", cex=0.75)
    axis(side=2)
    axis(side=1, at=dat$X[c(TRUE, FALSE)], labels=dat$Base[c(TRUE, FALSE)], las=2, cex.axis=0.75)
    title(paste(sn, "R1", sep=" "))
    qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R2_raw_quals.txt", sep=""), sep="/")
    if(!file.exists(qr2_file)) {
        plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
        text(x=0.5, y=0.5, "No R2 file found.", cex=1.5, col="black")
    } else{
        dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        # Make a dummy variable for position because some of the classes are binned
        dat$X <- 1:nrow(dat)
        # Make a plot
        plot(dat$QMean ~ dat$X, type="n", xlab="Position in Read", ylab="Quality", axes=F, ylim=c(0, 45))
        segments(x0=dat$X, y1=dat$Q10, y0=dat$Q90, lwd=1, col="black")
        segments(x0=dat$X, y1=dat$Q25, y0=dat$Q75, lwd=8, col="grey")
        points(dat$QMean ~ dat$X, pch=19, col="black", cex=0.75)
        points(dat$QMedian ~ dat$X, pch=19, col="red", cex=0.75)
        axis(side=2)
        axis(side=1, at=dat$X[c(TRUE, FALSE)], labels=dat$Base[c(TRUE, FALSE)], las=2, cex.axis=0.75)
        title(paste(sn, "R2", sep=" "))
    }
}
par(mfrow=c(nsamp, 2), mar=c(4, 3.5, 1, 0), mgp=c(2.5, 0.75, 0))
plt_out <- sapply(samplenames, plotqual)
```

### Trimmed Read Qualities (FastQC-style)
The plots below show the variance in quality across the reads for each sample.
The black dot shows the mean quality, the red dot shows the median quality,
the grey shaded region shows the inter-quartile range, and the vertical black
lines show the 10th-90th percentile range.

```{r trim_read_quals_fastqc, echo=FALSE, message=FALSE, fig.width=8, fig.height=1.75*nrow(sheet)}
if(length(trim_samp) > 0) {
    plotqual <- function(sn) {
        qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R1_trim_quals.txt", sep=""), sep="/")
        dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        # Make a dummy variable for position because some of the classes are binned
        dat$X <- 1:nrow(dat)
        # Make a plot
        plot(dat$QMean ~ dat$X, type="n", xlab="Position in Read", ylab="Quality", axes=F, ylim=c(0, 45))
        segments(x0=dat$X, y1=dat$Q10, y0=dat$Q90, lwd=1, col="black")
        segments(x0=dat$X, y1=dat$Q25, y0=dat$Q75, lwd=8, col="grey")
        points(dat$QMean ~ dat$X, pch=19, col="black", cex=0.75)
        points(dat$QMedian ~ dat$X, pch=19, col="red", cex=0.75)
        axis(side=2)
        axis(side=1, at=dat$X[c(TRUE, FALSE)], labels=dat$Base[c(TRUE, FALSE)], las=2, cex.axis=0.75)
        title(paste(sn, "R1", sep=" "))
        qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R2_trim_quals.txt", sep=""), sep="/")
        if(!file.exists(qr2_file)) {
            plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
            text(x=0.5, y=0.5, "No R2 file found.", cex=1.5, col="black")
        } else{
            dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
            names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
            # Make a dummy variable for position because some of the classes are binned
            dat$X <- 1:nrow(dat)
            # Make a plot
            plot(dat$QMean ~ dat$X, type="n", xlab="Position in Read", ylab="Quality", axes=F, ylim=c(0, 45))
            segments(x0=dat$X, y1=dat$Q10, y0=dat$Q90, lwd=1, col="black")
            segments(x0=dat$X, y1=dat$Q25, y0=dat$Q75, lwd=8, col="grey")
            points(dat$QMean ~ dat$X, pch=19, col="black", cex=0.75)
            points(dat$QMedian ~ dat$X, pch=19, col="red", cex=0.75)
            axis(side=2)
            axis(side=1, at=dat$X[c(TRUE, FALSE)], labels=dat$Base[c(TRUE, FALSE)], las=2, cex.axis=0.75)
            title(paste(sn, "R2", sep=" "))
        }
    }
    par(mfrow=c(nsamp, 2), mar=c(4, 3.5, 1, 0), mgp=c(2.5, 0.75, 0))
    plt_out <- sapply(trim_samp, plotqual)
} else {
    print("No trimming performed.")
}
```

# Alignment Summaries
## HISAT2 Summaries {.tabset}
### Counts-Based
```{r hisat2_counts, echo=FALSE, message=FALSE}
library(knitr)
count_dat <- as.matrix(hisat_summary[,c("UniqueMapped", "MultiMapped", "DiscoMapped", "Unmapped")])
max_reads <- max(hisat_summary$Total)/1000000
at <- barplot(
    t(count_dat)/1000000,
    beside=FALSE,
    col=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
    ylim=c(0, max_reads*1.15),
    ylab="Fragment Count (Millions)",
    main="HISAT2 Count Plot",
    axes=FALSE)
axis(side=2)
axis(side=1, at=at, labels=as.character(hisat_summary$SampleName), cex.axis=0.6, las=2)
legend(
    "top",
    c("Uniquely Mapped", "Multiply Mapped", "Discordantly Mapped", "Unmapped"),
    fill=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
    ncol=4,
    cex=0.7)

names(hisat_summary) <- c("Sample Name", "Total Fragments", "Unmapped", "Uniquely Mapped", "Multiply Mapped", "Discordantly Mapped")
kable(hisat_summary, caption="Summary of alignment from HISAT2 based on fragment counts. Note that if the samples are paired-end, then each fragment is represented by 2 reads. If the samples are single-end, then each fragment is represented by 1 read.")
```

### Proportion-Based
```{r hisat2_prop, echo=FALSE, message=FALSE}
library(knitr)
hisat_summary <- read.table(paste(params["workdir"], "allsamples", "HISAT_Stats.txt", sep="/"), header=F)
count_dat <- as.matrix(hisat_summary[,c(4, 5, 6, 3)])
# Then make a proportion plot
prop_dat <- count_dat / hisat_summary$V2
barplot(
    t(prop_dat),
    beside=FALSE,
    col=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
    ylim=c(0, 1.15),
    ylab="Fraction",
    main="HISAT2 Proportion Plot",
    axes=FALSE)
legend(
    "top",
    c("Uniquely Mapped", "Multiply Mapped", "Discordantly Mapped", "Unmapped"),
    fill=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
    ncol=4,
    cex=0.7)
axis(side=2)
axis(side=1, at=at, labels=as.character(hisat_summary$V1), cex.axis=0.6, las=2)

hisat_prop <- data.frame(
    SN=as.character(hisat_summary$V1),
    TO=rep("100%", nrow(hisat_summary)),
    UNM=paste(as.character(round((hisat_summary$V3/hisat_summary$V2)*100, digits=2)), "%", sep=""),
    SM=paste(as.character(round((hisat_summary$V4/hisat_summary$V2)*100, digits=2)), "%", sep=""),
    MM=paste(as.character(round((hisat_summary$V5/hisat_summary$V2)*100, digits=2)), "%", sep=""),
    DM=paste(as.character(round((hisat_summary$V6/hisat_summary$V2)*100, digits=2)), "%", sep=""))
names(hisat_prop) <- c(
    "Sample Name",
    "Total Fragments",
    "Unmapped",
    "Uniquely Mapped",
    "Multiply Mapped",
    "Discordantly Mapped")
kable(hisat_prop, caption="Summary of alignment from HISAT2 based on percentage of total reads. Note that if the samples are paired-end, then each fragment is represented by 2 reads. If the samples are single-end, then each fragment is represented by 1 read.")
```

## Mapping Statistics
The following table summarizes alignment characteristics with the output from
`samtools stats`.

```{r map_stats, echo=FALSE, message=FALSE}
library(knitr)
mapping_summary <- read.table(paste(params["workdir"], "allsamples", "Samtools_Stats.txt", sep="/"), header=F)
names(mapping_summary) <- c(
    "Sample Name",
    "Reads Mapped*",
    "PCR Duplicate",
    "MAPQ = 0",
    "Max Read Length",
    "Average Read Length",
    "Average Read Quality")
kable(mapping_summary, caption="Summary of read mapping from SAMTools. *Note that this counts reads and not fragments.")
```

## Insert Size Metrics
The plot below shows the variance in insert size for each sample. The black dot
shows the mean insert size, the red dot shows the median insert size, the grey
shaded region shows the bin that encompasses 30% of the insert sizes, and the
black lines show the bin that encompasses 90% of the insert sizes.

The bin widths reported in the table are widths of intervals, centered around
the median, that encompass a certain percentage of the insert sizes. For a full
description of the bin widths, see the [Picard Documentation](https://broadinstitute.github.io/picard/picard-metric-definitions.html#InsertSizeMetrics).

```{r is_stats, echo=FALSE, message=FALSE}
library(knitr)
insertsize_file <- paste(params["workdir"], "allsamples", "IS_Stats.txt", sep="/")
if(!file.exists(insertsize_file)) {
    print("No insert size metrics found.")
} else {
    is_summary <- read.table(insertsize_file, header=F)
    # Calculate the widest interval that we would have to plot:
    # mean insert size + 1/2 of the 90% percentile bin
    lims <- is_summary$V3 + (is_summary$V8)/2
    max_is <- max(lims)
    plot(
        rep(0, nrow(is_summary)) ~ seq_along(is_summary$V1),
        type="n",
        xlab="",
        ylab="Insert Size (bp)",
        main="Insert Size Distribution",
        ylim=c(0, max_is*1.1),
        axes=FALSE)
    segments(x0=seq_along(is_summary$V1), y1=is_summary$V2-(is_summary$V8)/2, y0=is_summary$V2+(is_summary$V8)/2, lwd=1, col="black")
    segments(x0=seq_along(is_summary$V1), y1=is_summary$V2-(is_summary$V6)/2, y0=is_summary$V2+(is_summary$V6)/2, lwd=8, col="grey")
    points(is_summary$V3 ~ seq_along(is_summary$V1), pch=19, col="black", cex=0.75)
    points(is_summary$V2 ~ seq_along(is_summary$V1), pch=19, col="red", cex=0.75)
    axis(side=2)
    axis(side=1, at=seq_along(is_summary$V1), labels=is_summary$V1, las=2, cex.axis=0.75)

    is_summary$V3 <- round(is_summary$V3, 3)
    is_summary$V4 <- round(is_summary$V4, 3)
    names(is_summary) <- c(
        "Sample Name",
        "Median Insert Size",
        "Mean Insert Size",
        "Insert Size StdDev",
        "Width of 10% Bin",
        "Width of 30% Bin",
        "Width of 70% Bin",
        "Width of 90% Bin")
    kable(is_summary, caption="Insert size summary.")
}
```

## Counts Summaries {.tabset}
These plots are available as PDF vector images at the following path:

``r paste(params["outdir"], "Plots", sep="/")``

### Number of Expressed Features
This plot shows the number of features (genes) that have at least one read
mapping to them.

```{r expressed_features, echo=FALSE, message=FALSE}
subread_counts <- read.table(paste(params["workdir"], "allsamples", "subread_counts.txt", sep="/"), header=T, sep="\t", comment.char="#")
subread_counts <- subread_counts[,-c(1:6)]
num_expressed <- as.numeric(apply(subread_counts, 2, function(x) sum(x>0)))
at <- barplot(
    num_expressed,
    ylab="Number of Expressed Features",
    axes=FALSE)
axis(side=2)
axis(side=1, at=at, labels=names(subread_counts), las=2, cex.axis=0.7)
```

### Expression in Counts-per-million
Shown below is a distribution of expression values as log2(1+CPM). CPM (counts-per-million)
is a transformation of raw counts that accounts for the number of fragments
sequenced in the library, like FPKM. It does not account for gene length like
FPKM, however. You can compare CPM values for the same gene across samples,
but do not compare CPM values for different genes in the same sample.

```{r cpm_summary, echo=FALSE, message=FALSE, out.width="750", out.height="750"}
library(knitr)
cpm_plot <- paste(params["outdir"], "Plots", "cpm_plot.pdf", sep="/")
# Include as graphics
include_graphics(cpm_plot)
```

### Sample Clustering Heatmap
We then calculated the variance in CPM values for each gene across the sequenced
samples. The 500 genes with the highest variance in expression were used to
generate the following heatmap:

```{r var_hmp, echo=FALSE, message=FALSE, out.width="750", out.height="750"}
library(knitr)
heatmap_plot <- paste(params["outdir"], "Plots", "high_variance_heatmap.pdf", sep="/")
include_graphics(heatmap_plot)
```

### Multidimensional Scaling Plot
CPM values were then used to generate a multidimensional scaling (MDS) plot,
which functions similarly to a principal components plot:

```{r mds_plot, echo=FALSE, message=FALSE, out.width="750", out.height="750"}
library(knitr)
mds_plot <- paste(params["outdir"], "Plots", "mds_plot.pdf", sep="/")
include_graphics(mds_plot)
```


# DEG Testing
If experimental groups were supplied, we test for differential expression
among them with a quasi-likelihood test (using `glmQLFit` in `edgeR`). We apply
a `0.05` false discovery rate correction to the differential expression tests.
If you did not supply experimental groups, then this section will mostly be
empty.

## Experimental Groups
The following experimental groups were supplied to the pipeline. These are read
out of the samplesheet:

```{r expr_groups, echo=FALSE, message=FALSE}
library(knitr)
sheet_sub <- sheet[,c(1, 2)]
names(sheet_sub) <- c("Sample Name", "Group")
kable(sheet_sub, caption="Experimental groups.")
```

## DEG List
The top differentially expressed genes (DEGs) are given below. Comparisons are
reported as `Group2-Group1`, with `Group2` serving as the numerator for the fold
change calculations. That is, if `logFC` is positive, then the gene has higher
expression in `Group2` than in `Group1`. The files in the `DEGs/` directory
under the output directory follow this naming convention:
`DE_Group2-Group1_list.txt`.

```{r degs, echo=FALSE, message=FALSE, results="asis"}
library(knitr)
degdir <- paste(params["outdir"], "DEGs", sep="/")
if(!dir.exists(degdir)) {
    print("There were no groups defined, so there are no differentially expressed genes.")
} else {
    deg_files <- list.files(degdir, full.names=TRUE)
    if(length(deg_files) == 0) {
        print("There were no groups defined, so there are no differentially expressed genes.")
    } else {
        gene_names <- read.table(paste(params["outdir"], "gene_id_gene_name_map.txt", sep="/"), header=FALSE)
        names(gene_names) <- c("EnsemblID", "GeneName")
        for(i in 1:length(deg_files)) {
            curr_f <- deg_files[i]
            fname <- basename(curr_f)
            gps <- unlist(strsplit(fname, "_"))[2]
            d <- read.table(curr_f, header=TRUE)
            d_g <- merge(d, gene_names, by.x="genes", by.y="EnsemblID")
            d_g <- d_g[order(d_g$FDR),]
            if(nrow(d_g) < 25) {
                lim <- nrow(d_g)
            } else {
                lim <- 25
            }
            print(kable(d_g[1:lim,], caption=paste("Top DEGs at the 0.05 FDR for ", gps, sep="")))
        }
    }
}
```
