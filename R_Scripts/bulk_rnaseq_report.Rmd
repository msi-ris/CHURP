---
title: "PURR Summary"
output:
    html_document:
        smart: false
        theme: cerulean
        toc: true
        toc_depth: 3
        toc_float:
            collapsed: false
        number_sections: true
        df_print: paged
date: "`r format(Sys.time(), '%Y-%m-%d, %T')`"
params:
    pipeline: NA
    samplesheet: NA
    outdir: NA
    workdir: NA
---

```{r exportvars, echo=FALSE, message=FALSE}
for(key in names(params)) {
    do.call("Sys.setenv", params[key])
}

# Read in the data sets here so that we don't have to keep doing it later
read_summary <- read.table(paste(params["workdir"], "allsamples", "Read_Counts.txt", sep="/"), header=F)
# Set NAs in read summary to 0
read_summary[is.na(read_summary)] <- 0
sheet <- read.table(as.character(params["samplesheet"]), sep="|", header=FALSE, comment.char="#", stringsAsFactors=FALSE)
# Subset the sheet for those that were run - these are the rows in the read count summary
sheet <- sheet[sheet$V1 %in% read_summary$V1,]
samplenames <- sheet$V1
# Export the first sample in the read summary
firstrun <- samplenames[1]
Sys.setenv(firstrun=firstrun)
nsamp <- length(samplenames)
hisat_summary <- read.table(paste(params["workdir"], "allsamples", "HISAT_Stats.txt", sep="/"), header=F)
names(hisat_summary) <- c("SampleName", "Total", "Unmapped", "UniqueMapped", "MultiMapped", "DiscoMapped")
dup_summary <- read.table(paste(params["workdir"], "allsamples", "Dup_Stats.txt", sep="/"), header=F)
names(dup_summary) <- c("SampleName", "R1_Dup", "R2_Dup")
bbduk_summary <- read.table(paste(params["workdir"], "allsamples", "rRNA_kmers.txt", sep="/"), header=F)
names(bbduk_summary) <- c("SampleName", "rRNA_Fragments", "rRNA_Pct")
picard_rnaseq_summary <- read.table(paste(params["workdir"], "allsamples", "RNASeq_Metrics.txt", sep="/"), header=F)
names(picard_rnaseq_summary) <- c(
    "SampleName",
    "RIBOSOMAL_BASES", "CODING_BASES", "UTR_BASES", "INTRONIC_BASES", "INTERGENIC_BASES",
    "CORRECT_STRAND_READS", "INCORRECT_STRAND_READS", "PCT_RIBOSOMAL_BASES", "PCT_CODING_BASES", "PCT_UTR_BASES",
    "PCT_INTRONIC_BASES", "PCT_INTERGENIC_BASES", "PCT_USABLE_BASES", "PCT_CORRECT_STRAND_READS")
# Assume that the first sample is part of the same dataset as the others
first_read <- as.character(sheet$V3[1])
fastq_dir <- dirname(first_read)
```

# PURR: Pipeline for UMII/RIS RNASeq Analysis

![](/home/msistaff/public/CHURP_Deps/Assets/UMII_Graphic_rs.png)

PURR is the RNASeq analysis pipeline that is housed within CHURP, the
**C**ollection of **H**ierarchical **U**MII/**R**IS **P**ipelines. CHURP is
developed and maintained by the Research Informatics Solutions (RIS) group at
MSI with funding provided by the University of Minnesota Informatics Institute
(UMII).

<https://www.msi.umn.edu/>

<https://research.umn.edu/units/umii>

# Key Figures and Summaries
## Experiment Summary
The location of the FASTQ files for this run is ``r fastq_dir``

A tabular summary of the samples and reads that were analyzed is shown below:

```{r samplesheet_sum, echo=FALSE, message=FALSE}
library(knitr)
# Define an NA-robust function here
base_na <- function(x) {
    if(is.na(x)) {
        return("NA")
    } else {
        return(basename(x))
    }
}
# Change the full R1/R2 paths into basenames
sheet$V3 <- as.character(sapply(sheet$V3, base_na))
sheet$V4 <- as.character(sapply(sheet$V4, base_na))
# And the reference, too
# Keep only sample name, group, R1, R2, Trim, rmdup, Trim opts, unstranded
sumsheet <- sheet[,c(1, 2, 3, 4, 7, 8, 9, 12)]
# Make the names nice
names(sumsheet) <- c(
    "Sample Name",
    "Group",
    "R1",
    "R2",
    "Trim?",
    "Remove Dups?",
    "Trim Options",
    "Strand")
sumsheet
```

## Fragment Counts Plot
```{r counts_sum, echo=FALSE, message=FALSE}
read_dat <- matrix(
    c(read_summary$V2, read_summary$V4)/1000000,
    byrow=FALSE,
    nrow=nrow(read_summary)
    )
max_reads <- max(read_dat)
at <- barplot(
    t(read_dat),
    beside=TRUE,
    ylim=c(0, max_reads*1.2),
    axes=FALSE,
    col=c("#d95f02", "#1b9e77"),
    ylab="Fragment Count (Millions)",
    main="Fragment Counts")
legend("top", c("Raw", "Trimmed"), fill=c("#d95f02", "#1b9e77"), ncol=2)
axis(side=2)
axis(side=1, at=apply(at, 2, mean), labels=as.character(read_summary$V1), cex.axis=0.6, las=2)
```

## Read Quality Plots {.tabset}
### Raw Reads

```{r raw_qual_sum, echo=FALSE, message=FALSE, fig.width=8, fig.height=0.7*nrow(sheet)}
plotqual_first <- function(sn) {
    allquals <- matrix(0:45)
    image(
        allquals,
        breaks=c(0, 10, 20, 25, 30, 40, 45),
        col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
        axes=FALSE,
        main="Quality Key")
    axis(side=1, at=seq(0, 1, length.out=46)[c(TRUE, FALSE)], labels=as.character(0:45)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)

    plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
    qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R1_raw_quals.txt", sep=""), sep="/")
    dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
    names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
    # Make a plot
    image(
        as.matrix(dat$QMean),
        breaks=c(0, 10, 20, 25, 30, 40, 45),
        col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
        axes=FALSE,
        main="Mean R1 Quality")
    mtext(side=2, font=2, cex=0.5, las=2, sn)
    qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R2_raw_quals.txt", sep=""), sep="/")
    if(!file.exists(qr2_file)) {
        plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
        text(x=0.5, y=0.5, "No R2", cex=1, col="black")
    } else{
        dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE,
            main="Mean R2 Quality")
    }
}

plotqual <- function(sn) {
    qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R1_raw_quals.txt", sep=""), sep="/")
    dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
    names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
    # Make a plot
    image(
        as.matrix(dat$QMean),
        breaks=c(0, 10, 20, 25, 30, 40, 45),
        col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
        axes=FALSE)
    mtext(side=2, font=2, cex=0.5, las=2, sn)
    qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R2_raw_quals.txt", sep=""), sep="/")
    if(!file.exists(qr2_file)) {
        plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
        text(x=0.5, y=0.5, "No R2", cex=1, col="black")
    } else{
        dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE)
    }
}

plotqual_last <- function(sn) {
    qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R1_raw_quals.txt", sep=""), sep="/")
    dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
    names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
    # Make a plot
    image(
        as.matrix(dat$QMean),
        breaks=c(0, 10, 20, 25, 30, 40, 45),
        col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
        axes=FALSE)
    mtext(side=2, font=2, cex=0.5, las=2, sn)
    axis(side=1, at=seq(0, 1, length.out=nrow(dat))[c(TRUE, FALSE)], labels=as.character(dat$Base)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)
    qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R2_raw_quals.txt", sep=""), sep="/")
    if(!file.exists(qr2_file)) {
        plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
        text(x=0.5, y=0.5, "No R2", cex=1, col="black")
    } else{
        dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
        dat$X <- 1:nrow(dat)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE)
        axis(side=1, at=seq(0, 1, length.out=nrow(dat))[c(TRUE, FALSE)], labels=as.character(dat$Base)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)
    }
}
par(mfrow=c(nsamp+1, 2))
# Set the margins of the top to be high on the first two so we can add the R1/R2 labels
par(mar=c(1.1, 5, 1.1, 0.1), mgp=c(1.25, 0.15, 0))
dummy <- plotqual_first(samplenames[1])
par(mar=c(1.1, 5, 1.1, 0.1))
dummy <- sapply(samplenames[3:nsamp-1], plotqual)
par(mar=c(2.5, 5, 0.1, 0.1), mgp=c(1.25, 0.15, 0))
dummy <- plotqual_last(samplenames[nsamp])
```

### Trimmed Reads
```{r trim_qual_sum, echo=FALSE, message=FALSE, fig.width=8, fig.height=0.7*nrow(sheet)}
trim_samp <- sheet$V1[sheet$V7 == "yes"]
if(length(trim_samp) > 0) {
    plotqual_first <- function(sn) {
        allquals <- matrix(0:45)
        image(
            allquals,
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE,
            main="Quality Key")
        axis(side=1, at=seq(0, 1, length.out=46)[c(TRUE, FALSE)], labels=as.character(0:45)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)

        plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
        qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R1_trim_quals.txt", sep=""), sep="/")
        dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        # Make a plot
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE,
            main="Mean R1 Quality")
        mtext(side=2, font=2, cex=0.5, las=2, sn)
        qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R2_trim_quals.txt", sep=""), sep="/")
        if(!file.exists(qr2_file)) {
            plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
            text(x=0.5, y=0.5, "No R2", cex=1, col="black")
        } else{
            dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
            names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
            image(
                as.matrix(dat$QMean),
                breaks=c(0, 10, 20, 25, 30, 40, 45),
                col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
                axes=FALSE,
                main="Mean R2 Quality")
        }
    }

    plotqual <- function(sn) {
        qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R1_trim_quals.txt", sep=""), sep="/")
        dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        # Make a plot
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE)
        mtext(side=2, font=2, cex=0.5, las=2, sn)
        qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R2_trim_quals.txt", sep=""), sep="/")
        if(!file.exists(qr2_file)) {
            plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
            text(x=0.5, y=0.5, "No R2", cex=1, col="black")
        } else{
            dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
            names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
            image(
                as.matrix(dat$QMean),
                breaks=c(0, 10, 20, 25, 30, 40, 45),
                col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
                axes=FALSE)
        }
    }

    plotqual_last <- function(sn) {
        qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R1_trim_quals.txt", sep=""), sep="/")
        dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        # Make a plot
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE)
        mtext(side=2, font=2, cex=0.5, las=2, sn)
        axis(side=1, at=seq(0, 1, length.out=nrow(dat))[c(TRUE, FALSE)], labels=as.character(dat$Base)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)
        qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R2_trim_quals.txt", sep=""), sep="/")
        if(!file.exists(qr2_file)) {
            plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
            text(x=0.5, y=0.5, "No R2", cex=1, col="black")
        } else{
            dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
            dat$X <- 1:nrow(dat)
            names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
            image(
                as.matrix(dat$QMean),
                breaks=c(0, 10, 20, 25, 30, 40, 45),
                col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
                axes=FALSE)
            axis(side=1, at=seq(0, 1, length.out=nrow(dat))[c(TRUE, FALSE)], labels=as.character(dat$Base)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)
        }
    }
    nsamp <- length(trim_samp)
    par(mfrow=c(nsamp+1, 2))
    # Set the margins of the top to be high on the first two so we can add the R1/R2 labels
    par(mar=c(1.1, 5, 1.1, 0.1), mgp=c(1.25, 0.15, 0))
    dummy <- plotqual_first(trim_samp[1])
    par(mar=c(1.1, 5, 1.1, 0.1))
    dummy <- sapply(trim_samp[3:nsamp-1], plotqual)
    par(mar=c(2.5, 5, 0.1, 0.1), mgp=c(1.25, 0.15, 0))
    dummy <- plotqual_last(trim_samp[nsamp])
    } else {
        print("No trimming performed.")
    }
```

## HISAT2 Plots {.tabset}
### Counts
```{r hisat2_counts_sum, echo=FALSE, message=FALSE}
count_dat <- as.matrix(hisat_summary[,c("UniqueMapped", "MultiMapped", "DiscoMapped", "Unmapped")])
max_reads <- max(hisat_summary$Total)/1000000
at <- barplot(
    t(count_dat)/1000000,
    beside=FALSE,
    col=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
    ylim=c(0, max_reads*1.2),
    ylab="Fragment Count (Millions)",
    main="HISAT2 Count Plot",
    axes=FALSE)
axis(side=2)
axis(side=1, at=at, labels=as.character(hisat_summary$SampleName), cex.axis=0.6, las=2)
legend(
    "top",
    c("Uniquely Mapped", "Multiply Mapped", "Discordantly Mapped", "Unmapped"),
    fill=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
    ncol=4,
    cex=0.7)
```

### Proportions
```{r hisat2_prop_sum, echo=FALSE, message=FALSE}
count_dat <- as.matrix(hisat_summary[,c("UniqueMapped", "MultiMapped", "DiscoMapped", "Unmapped")])
# Then make a proportion plot
prop_dat <- count_dat / hisat_summary$Total
barplot(
    t(prop_dat),
    beside=FALSE,
    col=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
    ylim=c(0, 1.15),
    ylab="Proportion",
    main="HISAT2 Proportion Plot",
    axes=FALSE)
legend(
    "top",
    c("Uniquely Mapped", "Multiply Mapped", "Discordantly Mapped", "Unmapped"),
    fill=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
    ncol=4,
    cex=0.7)
axis(side=2)
axis(side=1, at=at, labels=as.character(hisat_summary$SampleName), cex.axis=0.6, las=2)
```

## Expression Plots {.tabset}
### Expressed Genes
```{r expressed_sum, echo=FALSE, message=FALSE}
subread_counts <- read.table(paste(params["workdir"], "allsamples", "subread_counts.txt", sep="/"), header=T, sep="\t", comment.char="#")
subread_counts <- subread_counts[,-c(1:6)]
num_expressed <- as.numeric(apply(subread_counts, 2, function(x) sum(x>0)))
maxexpr <- max(num_expressed)
at <- barplot(
    num_expressed,
    ylab="Number of Expressed Features",
    ylim=c(0, maxexpr*1.2),
    col="#1f78b4",
    axes=FALSE)
axis(side=2)
axis(side=1, at=at, labels=names(subread_counts), las=2, cex.axis=0.7)
```

### CPM

```{r cpm_sum, echo=FALSE, message=FALSE, out.width="800", out.height="800"}
library(knitr)
cpm_plot <- paste(params["outdir"], "Plots", "cpm_plot.pdf", sep="/")
include_graphics(cpm_plot)
```

### Clustering Heatmap

```{r hmp_sum, echo=FALSE, message=FALSE, out.width="800", out.height="800"}
library(knitr)
heatmap_plot <- paste(params["outdir"], "Plots", "high_variance_heatmap.pdf", sep="/")
include_graphics(heatmap_plot)
```

### MDS

```{r mds_sum, echo=FALSE, message=FALSE, out.width="800", out.height="800"}
library(knitr)
mds_plot <- paste(params["outdir"], "Plots", "mds_plot.pdf", sep="/")
include_graphics(mds_plot)
```

## DEG Summary
```{r deg_overview, echo=FALSE, message=FALSE, results="asis"}
library(knitr)
degdir <- paste(params["outdir"], "DEGs", sep="/")
if(!dir.exists(degdir)) {
    print("There were no groups defined, so there are no differentially expressed genes.")
} else {
    deg_files <- list.files(degdir, full.names=TRUE)
    if(length(deg_files) == 0) {
        print("There were no groups defined, so there are no differentially expressed genes.")
    } else {
        gene_names <- read.table(paste(params["outdir"], "gene_id_gene_name_map.txt", sep="/"), header=FALSE)
        names(gene_names) <- c("EnsemblID", "GeneName")
        for(i in 1:length(deg_files)) {
            curr_f <- deg_files[i]
            fname <- basename(curr_f)
            gps <- unlist(strsplit(fname, "_"))[2]
            d <- read.table(curr_f, header=TRUE)
            d_g <- merge(d, gene_names, by.x="genes", by.y="EnsemblID")
            d_g <- d_g[order(d_g$FDR),]
            if(nrow(d_g) < 10) {
                lim <- nrow(d_g)
            } else {
                lim <- 10
            }
            print(kable(d_g[1:lim,], caption=paste("Top 10 DEGs at the 0.05 FDR for ", gps, sep="")))
        }
    }
}
```

# Run Summary
## General Workflow
### Read QC
A subsample of 10,000 reads or read pairs were sampled from each sample's reads.
This subsample of 10,000 reads was searched for contamination from ribosomal
RNA using a representative rRNA sequence list from the SILVA database release
132. Raw reads were summarized with FastQC, and optionally trimmed with
Trimmomatic. If trimmed, the cleaned reads are re-assessed with FastQC. Length,
quality, and duplication metrics were extracted from each FastQC run.

### Alignment
Trimmed reads (or raw reads, if `--no-trim` was specified) were aligned to the
reference genome with HISAT2. Duplicate reads based on alignment position were
marked with SAMTools. If `--rmdup` was specified, then the positional duplicates
were removed instead of marked. Alignments with duplicates marked were
summarized with Picard CollectRnaSeqMetrics to summarize the number of mapped
bases that occur in off-target regions and in annotated ribosomal regions.
Processed alignments were filtered of reads that have a mapping quality of less
than 60, and sorted by query name rather than position.

### Counts and Differential Expression testing
Cleaned and name-sorted alignments were processed with the featureCounts tool
from the subread package. Fragments were counted in a strand-specific manner,
unless the `--strand U` option was passed for a library that was prepared in
a strand-unspecific way. Both mates of a read pair were required to map to a
feature to be counted, if the data were paired-end.

Raw counts were imported into the `edgeR` package in R. Gnees that are shorter
than the specified minimum length (`--min-len` argument, default 200bp) were
pruned from the counts matrix before differential expression testing. If
experimental groups were specified (`-e` argument), then the differential
expression testing was peformed with a quasi-likelihood test in `edgeR` between
all pairwise combinations of groups. A 0.05 false discovery rate correction
was applied to the tests.

## Results and Intermediate Files
### Output Directory
The output directory is located at

``r params["outdir"]``

This directory contains final results files and log files for the pipeline. Be
sure to save these files if you would like to keep them. However, the pipeline
script and samplesheet (reproduced below) are sufficient to recreate all output
files. It will just require additional compute time and service units. The
following directories are of interest:

- ``r paste(params["outdir"], "Counts", sep="/")``

    Contains raw and CPM-transformed counts for each gene in the supplied GTF
    annotation.

- ``r paste(params["outdir"], "DEGs", sep="/")``

    Contains a list of significantly differentially expressed genes, if
    experimental groups were supplied. If differential expression analysis was
    conducted, but no genes passed thresholds for significance, then the files
    will only have a header. Pairwise combinations of groups are tested for
    significance, so this directory may contain multiple files.

- ``r paste(params["outdir"], "Coordinate_Sorted_BAMs", sep="/")``

    Contains BAM alignments sorted on alignment coordinates and BAM index files
    for loading into IGV or other alignment visualization tools. There are both
    pre-filtered (`*markdup.bam` or `*rmdup.bam`) and post-filtered
    (`*Filtered_CoordSort.bam`) files. In this case, the filtering is performed
    on mapping quality.

- ``r paste(params["outdir"], "Dup_Stats", sep="/")``

    Contains per-read (2 files per sample for paired-end data) summaries of
    duplication levels in *raw* reads. These are extracted directly from the
    FastQC data file.

- ``r paste(params["outdir"], "RNASeqMetrics", sep="/")``

    Contains per-sample output files from Picard CollectRnaSeqMetrics from the
    pre-filtering BAM file. There are also per-sample metaplots of coverage
    bias across the transcripts.

- ``r paste(params["outdir"], "InsertSizeMetrics", sep="/")``

    Contains per-sample insert size summaries from Picard tools. The mean,
    median, and standard deviation are summarized in a table in the "Alignment
    Summaries" section of this report.

- ``r paste(params["outdir"], "Logs", sep="/")``

    Contains per-sample run logs for read QC, trimming, and alignment. Also
    contains a log file for counting reads and performing differential
    expression testing.

- ``r paste(params["outdir"], "Plots", sep="/")``

    Contains PDF vector images of DEG testing summary plots. The plots are also
    embedded into the "Counts Summaries" subsection of the "Alignment Summaries"
    section of this report.

### Work Directory
The work directory is located at

``r params["workdir"]``

This directory contains intermediate files for the pipeline. Be sure to save
these files if you would like to refer to them in the future. However, the
pipeline script and samplesheet (reproduced below) are sufficient to recreate
all intermediate files for the pipeline. The work directory contains the
following:

- ``r paste(params["workdir"], "allsamples", sep="/")``

    Summary files used to generate this report and final BAM files used for
    generating raw counts.

- ``r paste(params["workdir"], "singlesamples", sep="/")``

    Sub-directories, one for each sample, with FastQC reports, trimmed reads,
    intermediate SAM and BAM files, and alignment summary files. Refer to these
    if you would like to see the details of one particular sample. For example,
    if one sample has unexpected expression values, it may be because the
    sample is of low quality; this would be apparent in the read quality reports
    and the alignment summaries that are found in its work directory.

## Pipeline Script
The path to the pipeline script is ``r params["pipeline"]``

The pipeline script is printed below. You may copy and paste the following
script into a new plain text document to recreate the analyses run here. Be sure
to save it with UNIX line endings (`LF` rather than `CR` [Mac] or `CRLF`
[Windows] line endings), or else it will cause errors on Mesabi. Also be sure to
turn off "smart quotes" and "smart dashes" on any text editors that you use to
paste the following script. Smart quotes and smart dashes are not interpreted
correctly by the shell on Mesabi and will also cause errors.

<details><summary>

**Click to show pipeline script**

</summary>
```{bash pipeline_script, echo=FALSE, comment=NA}
cat $pipeline
```
</details>

## Samplesheet
The path to the samplesheet is ``r params["samplesheet"]``

The samplesheet is printed below, verbatim. It is cumbersome to read, but you
may copy and paste it into a plain text document to recreate the analyses run
here. Like the pipeline script, be sure to save it with UNIX line endings
(`LF` rather than `CR` [Mac] or `CRLF` [Windows]). Be sure to disable "smart
quotes" and "smart dashes" on the text editor.

<details><summary>

**Click to show samplesheet**

</summary>

```{bash samplesheet, echo=FALSE, comment=NA}
cat $samplesheet
```

</details>

The raw samplesheet is difficult to read, so we will print out a readable
summary below:

```{r samplesheet_readable, echo=FALSE, message=FALSE}
library(knitr)
# Define an NA-robust function here
base_na <- function(x) {
    if(is.na(x)) {
        return("NA")
    } else {
        return(basename(x))
    }
}
# Change the full R1/R2 paths into basenames
sheet$V3 <- as.character(sapply(sheet$V3, base_na))
sheet$V4 <- as.character(sapply(sheet$V4, base_na))
# And the reference, too
sheet$V10 <- as.character(sapply(sheet$V10, base_na))
sheet$V13 <- as.character(sapply(sheet$V13, base_na))
# Drop the output and work directories, columns 5 and 6
sheet <- sheet[,-c(5, 6)]
# Make the names nice
names(sheet) <- c(
    "Sample Name",
    "Group",
    "R1",
    "R2",
    "Trim?",
    "Remove Dups?",
    "Trimmomatic Options",
    "Reference Genome",
    "HISAT2 Options",
    "Strand",
    "GTF Name")
sheet
```

## Software Environment {.tabset}
### Single Sample Job Modules
This is the full list of loaded modules for each single-sample job, which
includes read trimming and read mapping.

```{bash single_sample_modules, echo=FALSE, comment=NA}
log_name="${outdir}/Logs/${firstrun}_Analysis.log"
log_start=$(($(grep -m 1 -n '^#BEGIN_MODULE' "${log_name}" | head -n 1 | cut -f 1 -d ':') + 2))
log_end=$(($(grep -m 1 -n '^#END_MODULES' "${log_name}" | head -n 1 | cut -f 1 -d ':') - 1))
head -n "${log_end}" "${log_name}" | tail -n "+${log_start}"
```
### Summary Job Modules
This is the full list of loaded modules for the summary job, which includes
counting and differential expression testing.

```{bash summary_modules, echo=FALSE, comment=NA}
log_name="${outdir}/Logs/BulkRNASeq_Analysis.log"
log_start=$(($(grep -n -m 1 '^#BEGIN_MODULES' "${log_name}" | head -n 1 | cut -f 1 -d ':') + 2))
log_end=$(($(grep -n -m 1 '^#END_MODULES' "${log_name}" | head -n 1 | cut -f 1 -d ':') - 1))
head -n "${log_end}" "${log_name}" | tail -n "+${log_start}"
```

# QC Metrics
## Read Counts
```{r read_counts, echo=FALSE, message=FALSE}
library(knitr)
names(read_summary) <- c(
    "Sample Name",
    "Raw R1 Count",
    "Raw R2 Count",
    "Trimmed R1 Count",
    "Trimmed R2 Count")
kable(read_summary, caption="Read count summary.")
```

## rRNA Contamination (Based on Kmer Matching) {.tabset}
These counts were based on searching a subset of the raw reads against a
reference database of ribosomal K-mers. Click on the table headers to show the
summaries of rRNA contamination.

### Plot
```{r bbduk_plot, echo=FALSE, message=FALSE}
plt_dat <- as.numeric(gsub("%", "", as.character(bbduk_summary$rRNA_Pct)))
at <- barplot(
    plt_dat/100,
    col="#e41a1c",
    ylim=c(0, 0.75),
    xlab="",
    ylab="Proportion rRNA",
    main="K-mer Based rRNA Contamination",
    axes=FALSE)
axis(side=1, at=at, labels=as.character(bbduk_summary$SampleName), las=2, cex.axis=0.6)
axis(side=2, at=seq(0, 0.6, by=0.05), labels=seq(0, 0.6, by=0.05))
rect(
    xleft=par("usr")[1],
    xright=par("usr")[2],
    ybottom=0.2,
    ytop=0.35,
    col=rgb(255/255, 237/255, 160/255, 0.5),
    border=NA
    )
rect(
    xleft=par("usr")[1],
    xright=par("usr")[2],
    ybottom=0.35,
    ytop=0.6,
    col=rgb(228/255, 26/255, 28/255, 0.25),
    border=NA
    )
# Dumb, but re-plot it to put it on the top
barplot(
    plt_dat/100,
    col="#e41a1c",
    ylim=c(0, 0.75),
    xlab="",
    ylab="Proportion rRNA",
    main="K-mer Based rRNA Contamination",
    axes=FALSE,
    add=TRUE)
```

### Table
```{r bbduk_table, echo=FALSE, message=FALSE}
library(knitr)
kable(bbduk_summary, caption="Number of read pairs (from subsample) and percentage of library that is estimated to be derived from ribosomal RNA.")
```

## Sequence Duplication {.tabset}
These plots show sequence duplication summaries, derived from FastQC output.
Click on the tab headers to show the various summaries.

### Overall Duplication
```{r dup_overall, echo=FALSE, message=FALSE}
plt_dat <- matrix(as.numeric(c(dup_summary$R1_Dup, dup_summary$R2_Dup)), nrow=2, byrow=TRUE)
at <- barplot(
    (100-plt_dat)/100,
    beside=TRUE,
    axes=F,
    col=c("#d95f02", "#1b9e77"),
    ylim=c(0, 1.1),
    xlab="",
    ylab="Proportion Duplicated",
    main="Total Duplication")
axis(side=1, at=apply(at, 2, mean), labels=as.character(dup_summary$SampleName), las=2, cex.axis=0.6)
axis(side=2, at=seq(0, 1, by=0.1), labels=seq(0, 1, by=0.1))
legend("top", c("R1", "R2"), fill=c("#d95f02", "#1b9e77"), ncol=2)
```

### Duplication Histograms
```{r dup_hist, echo=FALSE, message=FALSE, fig.width=8, fig.height=1.75*nrow(sheet)}
par(mfrow=c(nrow(sheet), 2), mar=c(4, 3.5, 1, 0), mgp=c(2.5, 0.75, 0))
plot_dup <- function(sn) {
    r1_dfile <- paste(params["outdir"], "Dup_Stats", paste(sn, "_R1_Dups.txt", sep=""), sep="/")
    r1_dup <- read.table(r1_dfile, header=FALSE, stringsAsFactors=FALSE)
    plt_dat <- as.matrix(r1_dup[, c(2, 3)])
    at <- barplot(
        t(plt_dat)/100,
        axes=F,
        beside=TRUE,
        col=c("#a6cee3", "#1f78b4"),
        ylim=c(0, 1),
        xlab="Duplication Level",
        ylab="Proportion",
        main=paste("Duplication in ", sn, " R1", sep=""))
    axis(side=1, at=apply(at, 2, mean), labels=as.character(r1_dup$V1), las=2, cex.axis=0.6)
    axis(side=2, at=seq(0, 1, by=0.05), labels=seq(0, 1, by=0.05))
    legend("top", c("Of Deduplicated", "Of Total"), fill=c("#a6cee3", "#1f78b4"), ncol=2)
    r2_dfile <- paste(params["outdir"], "Dup_Stats", paste(sn, "_R2_Dups.txt", sep=""), sep="/")
    if(!file.exists(r2_dfile)) {
            plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
            text(x=0.5, y=0.5, "No R2 file found.", cex=1.5, col="black")
        } else {
            r2_dup <- read.table(r2_dfile, header=FALSE, stringsAsFactors=FALSE)
            plt_dat <- as.matrix(r2_dup[, c(2, 3)])
            at <- barplot(
                t(plt_dat)/100,
                axes=F,
                beside=TRUE,
                col=c("#a6cee3", "#1f78b4"),
                ylim=c(0, 110),
                xlab="Duplication Level",
                ylab="Proportion",
                main=paste("Duplication in ", sn, " R2", sep=""))
            axis(side=1, at=apply(at, 2, mean), labels=as.character(r2_dup$V1), las=2, cex.axis=0.6)
            axis(side=2, at=seq(0, 1, by=0.05), labels=seq(0, 1, by=0.05))
            legend("top", c("Of Deduplicated", "Of Total"), fill=c("#a6cee3", "#1f78b4"), ncol=2)
    }
}
dummy <- sapply(samplenames, plot_dup)
```

## Picard RNASeq Metrics {.tabset}
These summaries are useful for identifying genomic DNA contamination, potential
strandedness mismatches between the pipeline settings and the data, and coverage
biases across transcripts. There is also another measure of ribosomal RNA
contamination, based on alignment to annotated rRNA features.

### gDNA Contamination Metrics
This plot will show the percentage of bases that map to off-target regions
(i.e., non-exon regions). Note that the counts and proportions here *exclude*
ribosomal mapping.

```{r gdna_plot, echo=FALSE, message=FALSE}
par(mar=c(4, 3.5, 1, 0), mgp=c(2.5, 0.75, 0))
cts_dat <- matrix(
    c(
        as.numeric(picard_rnaseq_summary$CODING_BASES),
        as.numeric(picard_rnaseq_summary$UTR_BASES),
        as.numeric(picard_rnaseq_summary$INTRONIC_BASES),
        as.numeric(picard_rnaseq_summary$INTERGENIC_BASES)
        )/1000000,
    byrow=TRUE,
    nrow=4)
max_ct <- max(cts_dat)
bar_cols <- c("#a6cee3", "#1f78b4", "#b2df8a", "#33a02c")
at <- barplot(
    cts_dat,
    beside=TRUE,
    axes=F,
    ylim=c(0, max_ct*1.2),
    ylab="Number of Bases in Primary Alignments (Millions)",
    main="Base Positions",
    xlab="",
    col=bar_cols)
axis(side=1, at=apply(at, 2, mean), labels=as.character(picard_rnaseq_summary$SampleName), las=2, cex.axis=0.6)
axis(side=2)
legend("top", c("Coding", "UTR", "Intron", "Intergenic"), fill=bar_cols, ncol=4)

prop_dat <- matrix(
    c(
        as.numeric(picard_rnaseq_summary$PCT_CODING_BASES),
        as.numeric(picard_rnaseq_summary$PCT_UTR_BASES),
        as.numeric(picard_rnaseq_summary$PCT_INTRONIC_BASES),
        as.numeric(picard_rnaseq_summary$PCT_INTERGENIC_BASES)
        ),
    byrow=TRUE,
    nrow=4)
at <- barplot(
    prop_dat,
    beside=FALSE,
    axes=F,
    ylim=c(0, 1.2),
    ylab="Proportion of Bases in Primary Alignments",
    main="Base Positions",
    xlab="",
    col=bar_cols)
axis(side=1, at=at, labels=as.character(picard_rnaseq_summary$SampleName), las=2, cex.axis=0.6)
axis(side=2, at=seq(0, 1, by=0.2), labels=seq(0, 1, by=0.2))
legend("top", c("Coding", "UTR", "Intron", "Intergenic"), fill=bar_cols, ncol=4)
```

### Strand Summary
This plot will summarize the mismatch between the observed and expected strand
directionality in the samples. Note that for unstranded libraries, these values
will all be 0.

```{r strand_plot, echo=FALSE, message=FALSE}
plot_dat <- as.numeric(picard_rnaseq_summary$PCT_CORRECT_STRAND_READS)
par(mar=c(4, 3.5, 1, 0), mgp=c(2.5, 0.75, 0))
at <- barplot(
    plot_dat,
    col="#1f78b4",
    ylim=c(0, 1.1),
    xlab="",
    ylab="Proportion Correct Strand",
    main="Strand Agreement",
    axes=F)
axis(side=1, at=at, labels=as.character(picard_rnaseq_summary$SampleName), las=2, cex.axis=0.6)
axis(side=2)
```

### Mapping-based rRNA Contamination
This plot will show the proportion fo bases that map to annotated rRNA features.

```{r picard_rrna, echo=FALSE, message=FALSE}
plot_dat <- as.numeric(picard_rnaseq_summary$PCT_RIBOSOMAL_BASES)
par(mar=c(4, 3.5, 1, 0), mgp=c(2.5, 0.75, 0))
at <- barplot(
    plot_dat,
    col="#e41a1c",
    ylim=c(0, 0.75),
    xlab="",
    ylab="Proportion Ribosomal Bases",
    main="rRNA Contamination (Mapping)",
    axes=FALSE)
rect(
    xleft=par("usr")[1],
    xright=par("usr")[2],
    ybottom=0.2,
    ytop=0.35,
    col=rgb(255/255, 237/255, 160/255, 0.5),
    border=NA
    )
rect(
    xleft=par("usr")[1],
    xright=par("usr")[2],
    ybottom=0.35,
    ytop=0.6,
    col=rgb(228/255, 26/255, 28/255, 0.25),
    border=NA
    )
axis(side=1, at=at, labels=as.character(picard_rnaseq_summary$SampleName), las=2, cex.axis=0.6)
axis(side=2)
barplot(
    plot_dat,
    col="#e41a1c",
    ylim=c(0, 0.75),
    xlab="",
    ylab="Proportion Ribosomal Bases",
    main="rRNA Contamination (Mapping)",
    axes=FALSE,
    add=TRUE)
```

### Coverage Bias
This plot will show normalized coverage across all transcripts. Ideally, the
curve is symmetrical, showing no bias toward one end of the transcripts.

```{r coverage_bias, echo=FALSE, message=FALSE, fig.width=8, fig.height=1.25*nrow(sheet)}
samprow <- ceiling(nrow(sheet)/2)
par(mfrow=c(samprow, 2), mar=c(4, 3.5, 1, 0), mgp=c(2.5, 0.75, 0))
plot_cov <- function(sn) {
    cf <- paste(params["outdir"], "RNASeqMetrics", paste(sn, "_Metrics.txt", sep=""), sep="/")
    # Wrap this read in a tryCatch for the cases where there are no normalized coverage numbers
    cov_dat <- tryCatch(
        {read.table(cf, header=FALSE, stringsAsFactors=FALSE, skip=11)},
        error=function(x) {
            return(data.frame())
        }
        )
    if(length(cov_dat) > 0) {
        plot(
            cov_dat$V2 ~ cov_dat$V1,
            type="l",
            lwd=2,
            col="#1f78b4",
            xlab="Normalized Position",
            ylab="Normalized Coverage",
            main=sn,
            ylim=c(0, 1.7)
            )
        abline(h=1, lwd=1, col="grey", lty=3)
    } else {
        plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
        text(x=0.5, y=0.5, "No Bias Metrics Found", cex=1, col="black")
    }
}
dummy <- sapply(samplenames, plot_cov)
```

## Read Qualities {.tabset}
Click on the tab headers to show plots of raw and trimmed read qualities.

### Raw Read Qualities (Compact style)
These plots show the read qualities as they came off the sequencing instrument.
```{r raw_read_quals, echo=FALSE, message=FALSE, fig.width=8, fig.height=0.7*nrow(sheet)}
plotqual_first <- function(sn) {
    allquals <- matrix(0:45)
    image(
        allquals,
        breaks=c(0, 10, 20, 25, 30, 40, 45),
        col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
        axes=FALSE,
        main="Quality Key")
    axis(side=1, at=seq(0, 1, length.out=46)[c(TRUE, FALSE)], labels=as.character(0:45)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)

    plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
    qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R1_raw_quals.txt", sep=""), sep="/")
    dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
    names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
    # Make a plot
    image(
        as.matrix(dat$QMean),
        breaks=c(0, 10, 20, 25, 30, 40, 45),
        col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
        axes=FALSE,
        main="Mean R1 Quality")
    mtext(side=2, font=2, cex=0.5, las=2, sn)
    qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R2_raw_quals.txt", sep=""), sep="/")
    if(!file.exists(qr2_file)) {
        plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
        text(x=0.5, y=0.5, "No R2", cex=1, col="black")
    } else{
        dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE,
            main="Mean R2 Quality")
    }
}

plotqual <- function(sn) {
    qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R1_raw_quals.txt", sep=""), sep="/")
    dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
    names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
    # Make a plot
    image(
        as.matrix(dat$QMean),
        breaks=c(0, 10, 20, 25, 30, 40, 45),
        col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
        axes=FALSE)
    mtext(side=2, font=2, cex=0.5, las=2, sn)
    qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R2_raw_quals.txt", sep=""), sep="/")
    if(!file.exists(qr2_file)) {
        plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
        text(x=0.5, y=0.5, "No R2", cex=1, col="black")
    } else{
        dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE)
    }
}

plotqual_last <- function(sn) {
    qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R1_raw_quals.txt", sep=""), sep="/")
    dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
    names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
    # Make a plot
    image(
        as.matrix(dat$QMean),
        breaks=c(0, 10, 20, 25, 30, 40, 45),
        col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
        axes=FALSE)
    mtext(side=2, font=2, cex=0.5, las=2, sn)
    axis(side=1, at=seq(0, 1, length.out=nrow(dat))[c(TRUE, FALSE)], labels=as.character(dat$Base)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)
    qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R2_raw_quals.txt", sep=""), sep="/")
    if(!file.exists(qr2_file)) {
        plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
        text(x=0.5, y=0.5, "No R2", cex=1, col="black")
    } else{
        dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
        dat$X <- 1:nrow(dat)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE)
        axis(side=1, at=seq(0, 1, length.out=nrow(dat))[c(TRUE, FALSE)], labels=as.character(dat$Base)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)
    }
}
par(mfrow=c(nsamp+1, 2))
# Set the margins of the top to be high on the first two so we can add the R1/R2 labels
par(mar=c(1.1, 5, 1.1, 0.1), mgp=c(1.25, 0.15, 0))
dummy <- plotqual_first(samplenames[1])
par(mar=c(1.1, 5, 1.1, 0.1))
dummy <- sapply(samplenames[3:nsamp-1], plotqual)
par(mar=c(2.5, 5, 0.1, 0.1), mgp=c(1.25, 0.15, 0))
dummy <- plotqual_last(samplenames[nsamp])
```

### Trimmed Read Qualities (Compact style)
These plots show read qualities post-trimming, if it was performed.
```{r trim_read_quals, echo=FALSE, message=FALSE, fig.width=8, fig.height=0.7*nrow(sheet)}
if(length(trim_samp) > 0) {
    plotqual_first <- function(sn) {
        allquals <- matrix(0:45)
        image(
            allquals,
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE,
            main="Quality Key")
        axis(side=1, at=seq(0, 1, length.out=46)[c(TRUE, FALSE)], labels=as.character(0:45)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)

        plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
        qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R1_trim_quals.txt", sep=""), sep="/")
        dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        # Make a plot
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE,
            main="Mean R1 Quality")
        mtext(side=2, font=2, cex=0.5, las=2, sn)
        qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R2_trim_quals.txt", sep=""), sep="/")
        if(!file.exists(qr2_file)) {
            plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
            text(x=0.5, y=0.5, "No R2", cex=1, col="black")
        } else{
            dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
            names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
            image(
                as.matrix(dat$QMean),
                breaks=c(0, 10, 20, 25, 30, 40, 45),
                col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
                axes=FALSE,
                main="Mean R2 Quality")
        }
    }

    plotqual <- function(sn) {
        qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R1_trim_quals.txt", sep=""), sep="/")
        dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        # Make a plot
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE)
        mtext(side=2, font=2, cex=0.5, las=2, sn)
        qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R2_trim_quals.txt", sep=""), sep="/")
        if(!file.exists(qr2_file)) {
            plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
            text(x=0.5, y=0.5, "No R2", cex=1, col="black")
        } else{
            dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
            names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
            image(
                as.matrix(dat$QMean),
                breaks=c(0, 10, 20, 25, 30, 40, 45),
                col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
                axes=FALSE)
        }
    }

    plotqual_last <- function(sn) {
        qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R1_trim_quals.txt", sep=""), sep="/")
        dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        # Make a plot
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE)
        mtext(side=2, font=2, cex=0.5, las=2, sn)
        axis(side=1, at=seq(0, 1, length.out=nrow(dat))[c(TRUE, FALSE)], labels=as.character(dat$Base)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)
        qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R2_trim_quals.txt", sep=""), sep="/")
        if(!file.exists(qr2_file)) {
            plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
            text(x=0.5, y=0.5, "No R2", cex=1, col="black")
        } else{
            dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
            dat$X <- 1:nrow(dat)
            names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
            image(
                as.matrix(dat$QMean),
                breaks=c(0, 10, 20, 25, 30, 40, 45),
                col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
                axes=FALSE)
            axis(side=1, at=seq(0, 1, length.out=nrow(dat))[c(TRUE, FALSE)], labels=as.character(dat$Base)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)
        }
    }
    nsamp <- length(trim_samp)
    par(mfrow=c(nsamp+1, 2))
    # Set the margins of the top to be high on the first two so we can add the R1/R2 labels
    par(mar=c(1.1, 5, 1.1, 0.1), mgp=c(1.25, 0.15, 0))
    dummy <- plotqual_first(trim_samp[1])
    par(mar=c(1.1, 5, 1.1, 0.1))
    dummy <- sapply(trim_samp[3:nsamp-1], plotqual)
    par(mar=c(2.5, 5, 0.1, 0.1), mgp=c(1.25, 0.15, 0))
    dummy <- plotqual_last(trim_samp[nsamp])
    } else {
        print("No trimming performed.")
    }
```

### Raw Read Qualities (FastQC-style)
The plots below show the variance in quality across the reads for each sample.
The black dot shows the mean quality, the red dot shows the median quality,
the grey shaded region shows the inter-quartile range, and the vertical black
lines show the 10th-90th percentile range.

```{r raw_read_quals_fastqc, echo=FALSE, message=FALSE, fig.width=8, fig.height=1.75*nrow(sheet)}
plotqual <- function(sn) {
    qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R1_raw_quals.txt", sep=""), sep="/")
    dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
    names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
    # Make a dummy variable for position because some of the classes are binned
    dat$X <- 1:nrow(dat)
    # Make a plot
    plot(dat$QMean ~ dat$X, type="n", xlab="Position in Read", ylab="Quality", axes=F, ylim=c(0, 45))
    segments(x0=dat$X, y1=dat$Q10, y0=dat$Q90, lwd=1, col="black")
    segments(x0=dat$X, y1=dat$Q25, y0=dat$Q75, lwd=8, col="grey")
    points(dat$QMean ~ dat$X, pch=19, col="black", cex=0.75)
    points(dat$QMedian ~ dat$X, pch=19, col="red", cex=0.75)
    axis(side=2)
    axis(side=1, at=dat$X[c(TRUE, FALSE)], labels=dat$Base[c(TRUE, FALSE)], las=2, cex.axis=0.75)
    title(paste(sn, "R1", sep=" "))
    qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R2_raw_quals.txt", sep=""), sep="/")
    if(!file.exists(qr2_file)) {
        plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
        text(x=0.5, y=0.5, "No R2 file found.", cex=1.5, col="black")
    } else{
        dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        # Make a dummy variable for position because some of the classes are binned
        dat$X <- 1:nrow(dat)
        # Make a plot
        plot(dat$QMean ~ dat$X, type="n", xlab="Position in Read", ylab="Quality", axes=F, ylim=c(0, 45))
        segments(x0=dat$X, y1=dat$Q10, y0=dat$Q90, lwd=1, col="black")
        segments(x0=dat$X, y1=dat$Q25, y0=dat$Q75, lwd=8, col="grey")
        points(dat$QMean ~ dat$X, pch=19, col="black", cex=0.75)
        points(dat$QMedian ~ dat$X, pch=19, col="red", cex=0.75)
        axis(side=2)
        axis(side=1, at=dat$X[c(TRUE, FALSE)], labels=dat$Base[c(TRUE, FALSE)], las=2, cex.axis=0.75)
        title(paste(sn, "R2", sep=" "))
    }
}
par(mfrow=c(nsamp, 2), mar=c(4, 3.5, 1, 0), mgp=c(2.5, 0.75, 0))
plt_out <- sapply(samplenames, plotqual)
```

### Trimmed Read Qualities (FastQC-style)
The plots below show the variance in quality across the reads for each sample.
The black dot shows the mean quality, the red dot shows the median quality,
the grey shaded region shows the inter-quartile range, and the vertical black
lines show the 10th-90th percentile range.

```{r trim_read_quals_fastqc, echo=FALSE, message=FALSE, fig.width=8, fig.height=1.75*nrow(sheet)}
if(length(trim_samp) > 0) {
    plotqual <- function(sn) {
        qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R1_trim_quals.txt", sep=""), sep="/")
        dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        # Make a dummy variable for position because some of the classes are binned
        dat$X <- 1:nrow(dat)
        # Make a plot
        plot(dat$QMean ~ dat$X, type="n", xlab="Position in Read", ylab="Quality", axes=F, ylim=c(0, 45))
        segments(x0=dat$X, y1=dat$Q10, y0=dat$Q90, lwd=1, col="black")
        segments(x0=dat$X, y1=dat$Q25, y0=dat$Q75, lwd=8, col="grey")
        points(dat$QMean ~ dat$X, pch=19, col="black", cex=0.75)
        points(dat$QMedian ~ dat$X, pch=19, col="red", cex=0.75)
        axis(side=2)
        axis(side=1, at=dat$X[c(TRUE, FALSE)], labels=dat$Base[c(TRUE, FALSE)], las=2, cex.axis=0.75)
        title(paste(sn, "R1", sep=" "))
        qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_R2_trim_quals.txt", sep=""), sep="/")
        if(!file.exists(qr2_file)) {
            plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
            text(x=0.5, y=0.5, "No R2 file found.", cex=1.5, col="black")
        } else{
            dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
            names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
            # Make a dummy variable for position because some of the classes are binned
            dat$X <- 1:nrow(dat)
            # Make a plot
            plot(dat$QMean ~ dat$X, type="n", xlab="Position in Read", ylab="Quality", axes=F, ylim=c(0, 45))
            segments(x0=dat$X, y1=dat$Q10, y0=dat$Q90, lwd=1, col="black")
            segments(x0=dat$X, y1=dat$Q25, y0=dat$Q75, lwd=8, col="grey")
            points(dat$QMean ~ dat$X, pch=19, col="black", cex=0.75)
            points(dat$QMedian ~ dat$X, pch=19, col="red", cex=0.75)
            axis(side=2)
            axis(side=1, at=dat$X[c(TRUE, FALSE)], labels=dat$Base[c(TRUE, FALSE)], las=2, cex.axis=0.75)
            title(paste(sn, "R2", sep=" "))
        }
    }
    par(mfrow=c(nsamp, 2), mar=c(4, 3.5, 1, 0), mgp=c(2.5, 0.75, 0))
    plt_out <- sapply(trim_samp, plotqual)
} else {
    print("No trimming performed.")
}
```

# Alignment Summaries
## HISAT2 Summaries {.tabset}
### Counts-Based
```{r hisat2_counts, echo=FALSE, message=FALSE}
library(knitr)
count_dat <- as.matrix(hisat_summary[,c("UniqueMapped", "MultiMapped", "DiscoMapped", "Unmapped")])
max_reads <- max(hisat_summary$Total)/1000000
at <- barplot(
    t(count_dat)/1000000,
    beside=FALSE,
    col=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
    ylim=c(0, max_reads*1.2),
    ylab="Fragment Count (Millions)",
    main="HISAT2 Count Plot",
    axes=FALSE)
axis(side=2)
axis(side=1, at=at, labels=as.character(hisat_summary$SampleName), cex.axis=0.6, las=2)
legend(
    "top",
    c("Uniquely Mapped", "Multiply Mapped", "Discordantly Mapped", "Unmapped"),
    fill=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
    ncol=4,
    cex=0.7)

names(hisat_summary) <- c("Sample Name", "Total Fragments", "Unmapped", "Uniquely Mapped", "Multiply Mapped", "Discordantly Mapped")
kable(hisat_summary, caption="Summary of alignment from HISAT2 based on fragment counts. Note that if the samples are paired-end, then each fragment is represented by 2 reads. If the samples are single-end, then each fragment is represented by 1 read.")
```

### Proportion-Based
```{r hisat2_prop, echo=FALSE, message=FALSE}
library(knitr)
hisat_summary <- read.table(paste(params["workdir"], "allsamples", "HISAT_Stats.txt", sep="/"), header=F)
count_dat <- as.matrix(hisat_summary[,c(4, 5, 6, 3)])
# Then make a proportion plot
prop_dat <- count_dat / hisat_summary$V2
barplot(
    t(prop_dat),
    beside=FALSE,
    col=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
    ylim=c(0, 1.15),
    ylab="Fraction",
    main="HISAT2 Proportion Plot",
    axes=FALSE)
legend(
    "top",
    c("Uniquely Mapped", "Multiply Mapped", "Discordantly Mapped", "Unmapped"),
    fill=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
    ncol=4,
    cex=0.7)
axis(side=2)
axis(side=1, at=at, labels=as.character(hisat_summary$V1), cex.axis=0.6, las=2)

hisat_prop <- data.frame(
    SN=as.character(hisat_summary$V1),
    TO=rep("100%", nrow(hisat_summary)),
    UNM=paste(as.character(round((hisat_summary$V3/hisat_summary$V2)*100, digits=2)), "%", sep=""),
    SM=paste(as.character(round((hisat_summary$V4/hisat_summary$V2)*100, digits=2)), "%", sep=""),
    MM=paste(as.character(round((hisat_summary$V5/hisat_summary$V2)*100, digits=2)), "%", sep=""),
    DM=paste(as.character(round((hisat_summary$V6/hisat_summary$V2)*100, digits=2)), "%", sep=""))
names(hisat_prop) <- c(
    "Sample Name",
    "Total Fragments",
    "Unmapped",
    "Uniquely Mapped",
    "Multiply Mapped",
    "Discordantly Mapped")
kable(hisat_prop, caption="Summary of alignment from HISAT2 based on percentage of total reads. Note that if the samples are paired-end, then each fragment is represented by 2 reads. If the samples are single-end, then each fragment is represented by 1 read.")
```

## Mapping Statistics
The following table summarizes alignment characteristics with the output from
`samtools stats`.

```{r map_stats, echo=FALSE, message=FALSE}
library(knitr)
mapping_summary <- read.table(paste(params["workdir"], "allsamples", "Samtools_Stats.txt", sep="/"), header=F)
names(mapping_summary) <- c(
    "Sample Name",
    "Reads Mapped*",
    "PCR Duplicate",
    "MAPQ = 0",
    "Max Read Length",
    "Average Read Length",
    "Average Read Quality")
kable(mapping_summary, caption="Summary of read mapping from SAMTools. *Note that this counts reads and not fragments.")
```

## Insert Size Metrics
The plot below shows the variance in insert size for each sample. The black dot
shows the mean insert size, the red dot shows the median insert size, the grey
shaded region shows the bin that encompasses 30% of the insert sizes, and the
black lines show the bin that encompasses 90% of the insert sizes.

The bin widths reported in the table are widths of intervals, centered around
the median, that encompass a certain percentage of the insert sizes. For a full
description of the bin widths, see the [Picard Documentation](https://broadinstitute.github.io/picard/picard-metric-definitions.html#InsertSizeMetrics).

```{r is_stats, echo=FALSE, message=FALSE}
library(knitr)
insertsize_file <- paste(params["workdir"], "allsamples", "IS_Stats.txt", sep="/")
if(!file.exists(insertsize_file)) {
    print("No insert size metrics found.")
} else {
    is_summary <- read.table(insertsize_file, header=F)
    # Calculate the widest interval that we would have to plot:
    # mean insert size + 1/2 of the 90% percentile bin
    lims <- is_summary$V3 + (is_summary$V8)/2
    max_is <- max(lims)
    plot(
        rep(0, nrow(is_summary)) ~ seq_along(is_summary$V1),
        type="n",
        xlab="",
        ylab="Insert Size (bp)",
        main="Insert Size Distribution",
        ylim=c(0, max_is*1.2),
        axes=FALSE)
    segments(x0=seq_along(is_summary$V1), y1=is_summary$V2-(is_summary$V8)/2, y0=is_summary$V2+(is_summary$V8)/2, lwd=1, col="black")
    segments(x0=seq_along(is_summary$V1), y1=is_summary$V2-(is_summary$V6)/2, y0=is_summary$V2+(is_summary$V6)/2, lwd=8, col="grey")
    points(is_summary$V3 ~ seq_along(is_summary$V1), pch=19, col="black", cex=0.75)
    points(is_summary$V2 ~ seq_along(is_summary$V1), pch=19, col="red", cex=0.75)
    axis(side=2)
    axis(side=1, at=seq_along(is_summary$V1), labels=is_summary$V1, las=2, cex.axis=0.75)

    is_summary$V3 <- round(is_summary$V3, 3)
    is_summary$V4 <- round(is_summary$V4, 3)
    names(is_summary) <- c(
        "Sample Name",
        "Median Insert Size",
        "Mean Insert Size",
        "Insert Size StdDev",
        "Width of 10% Bin",
        "Width of 30% Bin",
        "Width of 70% Bin",
        "Width of 90% Bin")
    kable(is_summary, caption="Insert size summary.")
}
```

## Counts Summaries {.tabset}
### Subread Assignment Summary
These plots will show the breakdown of read assignment by `featureCounts`.

```{r subread_summary, echo=FALSE, message=FALSE, fig.width=8, fig.height=0.75*nrow(sheet)}
library(knitr)
subread_sum <- read.table(paste(params["workdir"], "allsamples", "subread_counts.txt.summary", sep="/"), header=TRUE)
plt_dat <- as.matrix(subread_sum[,-c(1)])
colnames(plt_dat) <- NULL
categories <- c(
    "Assigned",
    "Unmapped",
    "MQ<10",
    "Chimera",
    "TooShort",
    "Duplicate",
    "MultiMap",
    "Secondary",
    "Nonjunction",
    "NoFeatures",
    "Overlapping",
    "Ambiguity")
bar_cols <- c("#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928")
maxct <- max(plt_dat)/1000000
at <- barplot(
    plt_dat/1000000,
    beside=TRUE,
    col=bar_cols,
    axes=FALSE,
    xlim=c(0, maxct*1.4),
    ylab="",
    xlab="Fragment Count (Millions)",
    main="Subread Summary",
    horiz=TRUE)
axis(side=2, at=apply(at, 2, mean), labels=colnames(subread_sum[-c(1)]), las=2, cex.axis=0.6, lty=0)
axis(side=1)
legend("top", categories, fill=bar_cols, cex=0.65, ncol=6, inset=c(0, -0.025), xpd=TRUE)
```


```{r subread_summary_prop, echo=FALSE, message=FALSE}
plt_dat_prop <- t(plt_dat)
plt_dat_prop <- plt_dat_prop/rowSums(plt_dat_prop)
plt_dat_prop <- t(plt_dat_prop)
at <- barplot(
    plt_dat_prop,
    beside=FALSE,
    col=bar_cols,
    axes=FALSE,
    ylim=c(0, 1.4),
    xlab="",
    ylab="Fragment Proportions",
    main="Subread Summary")
axis(side=1, at=at, labels=colnames(subread_sum[-c(1)]), las=2, cex.axis=0.6)
axis(side=2, at=seq(0, 1, by=0.2), labels=seq(0, 1, by=0.2))
legend("top", categories, fill=bar_cols, cex=0.75, ncol=6)

# We want to transpose this table so that it scales vertically with the number
# of samples.
hdr <- as.character(subread_sum$Status)
samples <- colnames(subread_sum)[-c(1)]
t_subread <- as.data.frame(t(subread_sum[,-c(1)]))
rownames(t_subread) <- samples
colnames(t_subread) <- hdr
t_subread
```

### Number of Expressed Features
This plot shows the number of features (genes) that have at least one  fragment
mapping to them.

```{r expressed_features, echo=FALSE, message=FALSE}
subread_counts <- read.table(paste(params["workdir"], "allsamples", "subread_counts.txt", sep="/"), header=T, sep="\t", comment.char="#")
subread_counts <- subread_counts[,-c(1:6)]
num_expressed <- as.numeric(apply(subread_counts, 2, function(x) sum(x>0)))
maxexpr <- max(num_expressed)
at <- barplot(
    num_expressed,
    ylab="Number of Expressed Features",
    ylim=c(0, maxexpr*1.2),
    col="#1f78b4",
    axes=FALSE)
axis(side=2)
axis(side=1, at=at, labels=names(subread_counts), las=2, cex.axis=0.7)
```

### Expression in Counts-per-million
Shown below is a distribution of expression values as log2(1+CPM). CPM (counts-per-million)
is a transformation of raw counts that accounts for the number of fragments
sequenced in the library, like FPKM. It does not account for gene length like
FPKM, however. You can compare CPM values for the same gene across samples,
but do not compare CPM values for different genes in the same sample.

```{r cpm_summary, echo=FALSE, message=FALSE, out.width="750", out.height="750"}
library(knitr)
cpm_plot <- paste(params["outdir"], "Plots", "cpm_plot.pdf", sep="/")
# Include as graphics
include_graphics(cpm_plot)
```

### Sample Clustering Heatmap
We then calculated the variance in CPM values for each gene across the sequenced
samples. The 500 genes with the highest variance in expression were used to
generate the following heatmap:

```{r var_hmp, echo=FALSE, message=FALSE, out.width="750", out.height="750"}
library(knitr)
heatmap_plot <- paste(params["outdir"], "Plots", "high_variance_heatmap.pdf", sep="/")
include_graphics(heatmap_plot)
```

### Multidimensional Scaling Plot
CPM values were then used to generate a multidimensional scaling (MDS) plot,
which functions similarly to a principal components plot:

```{r mds_plot, echo=FALSE, message=FALSE, out.width="750", out.height="750"}
library(knitr)
mds_plot <- paste(params["outdir"], "Plots", "mds_plot.pdf", sep="/")
include_graphics(mds_plot)
```


# DEG Testing
If experimental groups were supplied, we test for differential expression
among them with a quasi-likelihood test (using `glmQLFit` in `edgeR`). We apply
a `0.05` false discovery rate correction to the differential expression tests.
If you did not supply experimental groups, then this section will mostly be
empty.

## Experimental Groups
The following experimental groups were supplied to the pipeline. These are read
out of the samplesheet:

```{r expr_groups, echo=FALSE, message=FALSE}
library(knitr)
sheet_sub <- sheet[,c(1, 2)]
names(sheet_sub) <- c("Sample Name", "Group")
kable(sheet_sub, caption="Experimental groups.")
```

## DEG List
The top differentially expressed genes (DEGs) are given below. Comparisons are
reported as `Group2-Group1`, with `Group2` serving as the numerator for the fold
change calculations. That is, if `logFC` is positive, then the gene has higher
expression in `Group2` than in `Group1`. The files in the `DEGs/` directory
under the output directory follow this naming convention:
`DE_Group2-Group1_list.txt`.

```{r degs, echo=FALSE, message=FALSE, results="asis"}
library(knitr)
degdir <- paste(params["outdir"], "DEGs", sep="/")
if(!dir.exists(degdir)) {
    print("There were no groups defined, so there are no differentially expressed genes.")
} else {
    deg_files <- list.files(degdir, full.names=TRUE)
    if(length(deg_files) == 0) {
        print("There were no groups defined, so there are no differentially expressed genes.")
    } else {
        gene_names <- read.table(paste(params["outdir"], "gene_id_gene_name_map.txt", sep="/"), header=FALSE)
        names(gene_names) <- c("EnsemblID", "GeneName")
        for(i in 1:length(deg_files)) {
            curr_f <- deg_files[i]
            fname <- basename(curr_f)
            gps <- unlist(strsplit(fname, "_"))[2]
            d <- read.table(curr_f, header=TRUE)
            d_g <- merge(d, gene_names, by.x="genes", by.y="EnsemblID")
            d_g <- d_g[order(d_g$FDR),]
            if(nrow(d_g) < 25) {
                lim <- nrow(d_g)
            } else {
                lim <- 25
            }
            print(kable(d_g[1:lim,], caption=paste("Top DEGs at the 0.05 FDR for ", gps, sep="")))
        }
    }
}
```
