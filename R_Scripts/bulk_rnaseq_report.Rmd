---
title: "PURR Summary"
output:
    html_document:
        smart: false
        theme: cerulean
        toc: true
        toc_depth: 3
        toc_float:
            collapsed: false
        number_sections: true
        df_print: paged
date: "`r format(Sys.time(), '%Y-%m-%d, %T')`"
params:
    pipeline: NA
    samplesheet: NA
    outdir: NA
    workdir: NA
---

```{r exportvars, echo=FALSE, message=FALSE}
for(key in names(params)) {
    do.call("Sys.setenv", params[key])
}

# Read in the data sets here so that we don't have to keep doing it later
read_summary <- read.table(paste(params["workdir"], "allsamples", "Read_Counts.txt", sep="/"), header=F)
# Set NAs in read summary to 0
read_summary[is.na(read_summary)] <- 0
sheet <- read.table(as.character(params["samplesheet"]), sep="|", header=FALSE, comment.char="#", stringsAsFactors=FALSE)
# Subset the sheet for those that were run - these are the rows in the read count summary
sheet <- sheet[sheet$V1 %in% read_summary$V1,]
samplenames <- sheet$V1
# Export the first sample in the read summary
firstrun <- samplenames[1]
Sys.setenv(firstrun=firstrun)
nsamp <- length(samplenames)
hisat_summary <- read.table(paste(params["workdir"], "allsamples", "HISAT_Stats.txt", sep="/"), header=F)
names(hisat_summary) <- c("SampleName", "Total", "Unmapped", "UniqueMapped", "MultiMapped", "DiscoMapped")
bbduk_summary <- read.table(paste(params["workdir"], "allsamples", "rRNA_kmers.txt", sep="/"), header=F)
names(bbduk_summary) <- c("SampleName", "rRNA_Fragments", "rRNA_Pct")
rnaseqc_summary <- read.table(paste(params["workdir"], "allsamples", "RNASeq_Metrics.txt", sep="/"), header=F, sep="\t", quote=NULL)
names(rnaseqc_summary) <- c("SampleName", "Statistic", "Value")
rnaseqc_summary_uns <- read.table(paste(params["workdir"], "allsamples", "RNASeq_Metrics_Unstranded.txt", sep="/"), header=F, sep="\t", quote=NULL)
names(rnaseqc_summary_uns) <- c("SampleName", "Statistic", "Value")
# Assume that the first sample is part of the same dataset as the others
first_read <- as.character(sheet$V3[1])
fastq_dir <- dirname(first_read)

# Set a "large dataset" flag
lg_cutoff <- 12
if(nsamp > lg_cutoff) {
    large_dataset <- TRUE
} else {
    large_dataset <- FALSE
}

# Generate the chunk offsets that we will use in the case of large datasets
if(large_dataset) {
    chunks <- cut(1:nsamp, breaks=unique(c(seq(0, nsamp, by=lg_cutoff), nsamp)), include.lowest=TRUE)
}
```

# PURR: Pipeline for UMII/RIS RNASeq Analysis

![](/home/msistaff/public/CHURP_Deps/Assets/UMII_Graphic_rs.png)

PURR is the RNASeq analysis pipeline that is housed within CHURP, the
**C**ollection of **H**ierarchical **U**MII/**R**IS **P**ipelines. CHURP is
developed and maintained by the Research Informatics Solutions (RIS) group at
MSI with funding provided by the University of Minnesota Informatics Institute
(UMII).

<https://www.msi.umn.edu/>

<https://research.umn.edu/units/umii>

# Key Figures and Summaries
## Experiment Summary
The location of the FASTQ files for this run is ``r fastq_dir``

This run consists of ``r nsamp`` samples.

A tabular summary of the samples and reads that were analyzed is shown below:

```{r samplesheet_sum, echo=FALSE, message=FALSE}
library(knitr)
# Define an NA-robust function here
base_na <- function(x) {
    if(is.na(x)) {
        return("NA")
    } else {
        return(basename(x))
    }
}
# Change the full R1/R2 paths into basenames
sheet$V3 <- as.character(sapply(sheet$V3, base_na))
sheet$V4 <- as.character(sapply(sheet$V4, base_na))
# And the reference, too
# Keep only sample name, group, R1, R2, Trim, rmdup, Trim opts, unstranded
sumsheet <- sheet[,c(1, 2, 3, 4, 7, 8, 9, 12)]
# Make the names nice
names(sumsheet) <- c(
    "Sample Name",
    "Group",
    "R1",
    "R2",
    "Trim?",
    "Remove Dups?",
    "Trim Options",
    "Strand")
sumsheet
```

```{r counts_sum, echo=FALSE, results='asis'}
read_dat <- matrix(
    c(read_summary$V2, read_summary$V4)/1000000,
    byrow=FALSE,
    nrow=nrow(read_summary)
    )
max_reads <- max(read_dat)
if(large_dataset) {
    cat("## Fragment Counts Plots {.tabset}\n")
    for(i in unique(chunks)) {
        idx <- which(chunks == i)
        cat("### Samples ", idx[1], " to ", idx[length(idx)], "\n")
        subdat <- read_dat[idx,]
        at <- barplot(
            t(subdat),
            beside=TRUE,
            ylim=c(0, max_reads*1.2),
            axes=FALSE,
        col=c("#d95f02", "#1b9e77"),
        ylab="Fragment Count (Millions)",
        main="Fragment Counts")
        legend("top", c("Raw", "Trimmed"), fill=c("#d95f02", "#1b9e77"), ncol=2)
        axis(side=2)
        axis(side=1, at=apply(at, 2, mean), labels=as.character(read_summary$V1[idx]), cex.axis=0.6, las=2)
        cat("\n\n")
    }
} else {
    cat("## Fragment Counts Plot\n")
    at <- barplot(
        t(read_dat),
        beside=TRUE,
        ylim=c(0, max_reads*1.2),
        axes=FALSE,
    col=c("#d95f02", "#1b9e77"),
    ylab="Fragment Count (Millions)",
    main="Fragment Counts")
    legend("top", c("Raw", "Trimmed"), fill=c("#d95f02", "#1b9e77"), ncol=2)
    axis(side=2)
    axis(side=1, at=apply(at, 2, mean), labels=as.character(read_summary$V1), cex.axis=0.6, las=2)
}
```

## Read Quality Plots
```{r raw_qual_sum, echo=FALSE, fig.width=8, fig.height=min(0.6*lg_cutoff, 2.4), results='asis'}
plotqual_first <- function(sn) {
    allquals <- matrix(0:45)
    image(
        allquals,
        breaks=c(0, 10, 20, 25, 30, 40, 45),
        col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
        axes=FALSE,
        main="Quality Key")
    axis(side=1, at=seq(0, 1, length.out=46)[c(TRUE, FALSE)], labels=as.character(0:45)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)

    plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
    qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_1.raw_quals.txt", sep=""), sep="/")
    dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
    names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
    # Make a plot
    image(
        as.matrix(dat$QMean),
        breaks=c(0, 10, 20, 25, 30, 40, 45),
        col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
        axes=FALSE,
        main="Mean R1 Quality")
    mtext(side=2, font=2, cex=0.5, las=2, sn)
    qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_2.raw_quals.txt", sep=""), sep="/")
    if(!file.exists(qr2_file)) {
        plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
        text(x=0.5, y=0.5, "No R2", cex=1, col="black")
    } else{
        dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE,
            main="Mean R2 Quality")
    }
}

plotqual <- function(sn) {
    qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_1.raw_quals.txt", sep=""), sep="/")
    dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
    names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
    # Make a plot
    image(
        as.matrix(dat$QMean),
        breaks=c(0, 10, 20, 25, 30, 40, 45),
        col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
        axes=FALSE)
    mtext(side=2, font=2, cex=0.5, las=2, sn)
    qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_2.raw_quals.txt", sep=""), sep="/")
    if(!file.exists(qr2_file)) {
        plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
        text(x=0.5, y=0.5, "No R2", cex=1, col="black")
    } else{
        dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE)
    }
}

plotqual_last <- function(sn) {
    qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_1.raw_quals.txt", sep=""), sep="/")
    dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
    names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
    # Make a plot
    image(
        as.matrix(dat$QMean),
        breaks=c(0, 10, 20, 25, 30, 40, 45),
        col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
        axes=FALSE)
    mtext(side=2, font=2, cex=0.5, las=2, sn)
    axis(side=1, at=seq(0, 1, length.out=nrow(dat))[c(TRUE, FALSE)], labels=as.character(dat$Base)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)
    qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_2.raw_quals.txt", sep=""), sep="/")
    if(!file.exists(qr2_file)) {
        plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
        text(x=0.5, y=0.5, "No R2", cex=1, col="black")
    } else{
        dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
        dat$X <- 1:nrow(dat)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE)
        axis(side=1, at=seq(0, 1, length.out=nrow(dat))[c(TRUE, FALSE)], labels=as.character(dat$Base)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)
    }
}

if(large_dataset) {
    cat("### Raw Reads {.tabset}\n")
    for(i in unique(chunks)) {
        idx <- which(chunks == i)
        cat("#### Samples ", idx[1], " to ", idx[length(idx)], "\n")
        subsamp <- samplenames[idx]
        nsubsamp <- length(subsamp)
        cat("\n\n")
        par(mfrow=c(nsubsamp+1, 2))
        # Set the margins of the top to be high on the first two so we can add the R1/R2 labels
        par(mar=c(1.1, 5, 1.1, 0.1), mgp=c(1.25, 0.15, 0))
        dummy <- plotqual_first(subsamp[1])
        par(mar=c(1.1, 5, 1.1, 0.1))
        dummy <- sapply(subsamp[3:nsubsamp-1], plotqual)
        par(mar=c(2.5, 5, 0.1, 0.1), mgp=c(1.25, 0.15, 0))
        dummy <- plotqual_last(subsamp[nsubsamp])
        cat("\n\n")
    }
} else {
    par(mfrow=c(nsamp+1, 2))
    # Set the margins of the top to be high on the first two so we can add the R1/R2 labels
    par(mar=c(1.1, 5, 1.1, 0.1), mgp=c(1.25, 0.15, 0))
    dummy <- plotqual_first(samplenames[1])
    par(mar=c(1.1, 5, 1.1, 0.1))
    dummy <- sapply(samplenames[3:nsamp-1], plotqual)
    par(mar=c(2.5, 5, 0.1, 0.1), mgp=c(1.25, 0.15, 0))
    dummy <- plotqual_last(samplenames[nsamp])
}
```

```{r trim_qual_sum, echo=FALSE, fig.width=8, fig.height=min(0.6*lg_cutoff, 2.4), results='asis'}
trim_samp <- sheet$V1[sheet$V7 == "yes"]
if(length(trim_samp) > 0) {
    plotqual_first <- function(sn) {
        allquals <- matrix(0:45)
        image(
            allquals,
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE,
            main="Quality Key")
        axis(side=1, at=seq(0, 1, length.out=46)[c(TRUE, FALSE)], labels=as.character(0:45)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)

        plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
        qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_1.trim_quals.txt", sep=""), sep="/")
        dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        # Make a plot
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE,
            main="Mean R1 Quality")
        mtext(side=2, font=2, cex=0.5, las=2, sn)
        qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_2.trim_quals.txt", sep=""), sep="/")
        if(!file.exists(qr2_file)) {
            plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
            text(x=0.5, y=0.5, "No R2", cex=1, col="black")
        } else{
            dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
            names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
            image(
                as.matrix(dat$QMean),
                breaks=c(0, 10, 20, 25, 30, 40, 45),
                col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
                axes=FALSE,
                main="Mean R2 Quality")
        }
    }

    plotqual <- function(sn) {
        qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_1.trim_quals.txt", sep=""), sep="/")
        dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        # Make a plot
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE)
        mtext(side=2, font=2, cex=0.5, las=2, sn)
        qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_2.trim_quals.txt", sep=""), sep="/")
        if(!file.exists(qr2_file)) {
            plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
            text(x=0.5, y=0.5, "No R2", cex=1, col="black")
        } else{
            dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
            names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
            image(
                as.matrix(dat$QMean),
                breaks=c(0, 10, 20, 25, 30, 40, 45),
                col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
                axes=FALSE)
        }
    }

    plotqual_last <- function(sn) {
        qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_1.trim_quals.txt", sep=""), sep="/")
        dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        # Make a plot
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE)
        mtext(side=2, font=2, cex=0.5, las=2, sn)
        axis(side=1, at=seq(0, 1, length.out=nrow(dat))[c(TRUE, FALSE)], labels=as.character(dat$Base)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)
        qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_2.trim_quals.txt", sep=""), sep="/")
        if(!file.exists(qr2_file)) {
            plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
            text(x=0.5, y=0.5, "No R2", cex=1, col="black")
        } else{
            dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
            dat$X <- 1:nrow(dat)
            names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
            image(
                as.matrix(dat$QMean),
                breaks=c(0, 10, 20, 25, 30, 40, 45),
                col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
                axes=FALSE)
            axis(side=1, at=seq(0, 1, length.out=nrow(dat))[c(TRUE, FALSE)], labels=as.character(dat$Base)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)
        }
    }
    if(large_dataset) {
        cat("### Trimmed Reads {.tabset}\n")
        for(i in unique(chunks)) {
            idx <- which(chunks == i)
            cat("#### Samples ", idx[1], " to ", idx[length(idx)], "\n")
            subsamp <- trim_samp[idx]
            nsubsamp <- length(subsamp)
            cat("\n\n")
            par(mfrow=c(nsubsamp+1, 2))
            # Set the margins of the top to be high on the first two so we can add the R1/R2 labels
            par(mar=c(1.1, 5, 1.1, 0.1), mgp=c(1.25, 0.15, 0))
            dummy <- plotqual_first(subsamp[1])
            par(mar=c(1.1, 5, 1.1, 0.1))
            dummy <- sapply(subsamp[3:nsubsamp-1], plotqual)
            par(mar=c(2.5, 5, 0.1, 0.1), mgp=c(1.25, 0.15, 0))
            dummy <- plotqual_last(subsamp[nsubsamp])
            cat("\n\n")
        }
    } else {
        cat("### Trimmed Reads\n")
        par(mfrow=c(nsamp+1, 2))
        # Set the margins of the top to be high on the first two so we can add the R1/R2 labels
        par(mar=c(1.1, 5, 1.1, 0.1), mgp=c(1.25, 0.15, 0))
        dummy <- plotqual_first(trim_samp[1])
        par(mar=c(1.1, 5, 1.1, 0.1))
        dummy <- sapply(trim_samp[3:nsamp-1], plotqual)
        par(mar=c(2.5, 5, 0.1, 0.1), mgp=c(1.25, 0.15, 0))
        dummy <- plotqual_last(trim_samp[nsamp])
    }
} else {
        cat("### Trimmed Reads\n\nNo trimming performed.")
    }
```

## HISAT2 Plots {.tabset}

```{r hisat2_counts_sum, echo=FALSE, message=FALSE, results="asis"}
count_dat <- as.matrix(hisat_summary[,c("UniqueMapped", "MultiMapped", "DiscoMapped", "Unmapped")])
max_reads <- max(hisat_summary$Total)/1000000
if(large_dataset) {
    cat("### Fragment Counts Plots {.tabset}\n")
    for(i in unique(chunks)) {
        idx <- which(chunks == i)
        cat("#### Samples ", idx[1], " to ", idx[length(idx)], "\n")
        subdat <- count_dat[idx,]
        at <- barplot(
            t(subdat)/1000000,
            beside=FALSE,
            col=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
            ylim=c(0, max_reads*1.2),
            ylab="Fragment Count (Millions)",
            main="HISAT2 Count Plot",
            axes=FALSE)
        axis(side=2)
        axis(side=1, at=at, labels=as.character(hisat_summary$SampleName)[idx], cex.axis=0.6, las=2)
        legend(
            "top",
            c("Uniquely Mapped", "Multiply Mapped", "Discordantly Mapped", "Unmapped"),
            fill=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
            ncol=4,
            cex=0.7)
        cat("\n\n")
    }
} else {
    cat("### Fragment Counts Plot\n")
    at <- barplot(
        t(count_dat)/1000000,
        beside=FALSE,
        col=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
        ylim=c(0, max_reads*1.2),
        ylab="Fragment Count (Millions)",
        main="HISAT2 Count Plot",
        axes=FALSE)
        axis(side=2)
        axis(side=1, at=at, labels=as.character(hisat_summary$SampleName), cex.axis=0.6, las=2)
        legend(
            "top",
            c("Uniquely Mapped", "Multiply Mapped", "Discordantly Mapped", "Unmapped"),
            fill=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
            ncol=4,
            cex=0.7)
}
```

```{r hisat2_prop_sum, echo=FALSE, message=FALSE, results="asis"}
# Then make a proportion plot
prop_dat <- count_dat / as.numeric(hisat_summary$Total)
if(large_dataset) {
    cat("### Fragment Proportions Plots {.tabset}\n")
    for(i in unique(chunks)) {
        idx <- which(chunks == i)
        cat("#### Samples ", idx[1], " to ", idx[length(idx)], "\n")
        subdat <- prop_dat[idx,]
        at <- barplot(
            t(subdat),
            beside=FALSE,
            col=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
            ylim=c(0, 1.2),
            ylab="Proportion",
            main="HISAT2 Proportion Plot",
            axes=FALSE)
        axis(side=2)
        axis(side=1, at=at, labels=as.character(hisat_summary$SampleName)[idx], cex.axis=0.6, las=2)
        legend(
            "top",
            c("Uniquely Mapped", "Multiply Mapped", "Discordantly Mapped", "Unmapped"),
            fill=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
            ncol=4,
            cex=0.7)
        cat("\n\n")
    }
} else {
    cat("### Fragment Counts Plot\n")
    at <- barplot(
        t(prop_dat),
        beside=FALSE,
        col=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
        ylim=c(0, 1.2),
        ylab="Proportion",
        main="HISAT2 Proportion Plot",
        axes=FALSE)
        axis(side=2)
        axis(side=1, at=at, labels=as.character(hisat_summary$SampleName), cex.axis=0.6, las=2)
        legend(
            "top",
            c("Uniquely Mapped", "Multiply Mapped", "Discordantly Mapped", "Unmapped"),
            fill=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
            ncol=4,
            cex=0.7)
}
```

## Expression Plots {.tabset}
```{r expressed_sum, echo=FALSE, message=FALSE, results="asis"}
subread_counts <- read.table(paste(params["workdir"], "allsamples", "subread_counts.txt", sep="/"), header=T, sep="\t", comment.char="#")
subread_counts <- subread_counts[,-c(1:6)]
num_expressed <- as.numeric(apply(subread_counts, 2, function(x) sum(x>0)))
maxexpr <- max(num_expressed)
if(large_dataset) {
    cat("### Expressed Features {.tabset}\n")
    for(i in unique(chunks)) {
        idx <- which(chunks == i)
        subdat <- num_expressed[idx]
        cat("#### Samples ", idx[1], " to ", idx[length(idx)], "\n")
        at <- barplot(
            subdat,
            ylab="Number of Expressed Features",
            ylim=c(0, maxexpr*1.2),
            col="#1f78b4",
            axes=FALSE)
        axis(side=2)
        axis(side=1, at=at, labels=names(subread_counts)[idx], las=2, cex.axis=0.7)
        cat("\n\n")
    }
} else {
    at <- barplot(
        num_expressed,
        ylab="Number of Expressed Features",
        ylim=c(0, maxexpr*1.2),
        col="#1f78b4",
        axes=FALSE)
    axis(side=2)
    axis(side=1, at=at, labels=names(subread_counts), las=2, cex.axis=0.7)
}
```

### CPM

```{r cpm_sum, echo=FALSE, message=FALSE, out.width="800", out.height="800"}
library(knitr)
cpm_plot <- paste(params["outdir"], "Plots", "cpm_plot.pdf", sep="/")
include_graphics(cpm_plot)
```

### Clustering Heatmap

```{r hmp_sum, echo=FALSE, message=FALSE, out.width="800", out.height="800"}
library(knitr)
heatmap_plot <- paste(params["outdir"], "Plots", "high_variance_heatmap.pdf", sep="/")
include_graphics(heatmap_plot)
```

### MDS

```{r mds_sum, echo=FALSE, message=FALSE, out.width="800", out.height="800"}
library(knitr)
mds_plot <- paste(params["outdir"], "Plots", "mds_plot.pdf", sep="/")
include_graphics(mds_plot)
```

## DEG Summary
```{r deg_overview, echo=FALSE, message=FALSE, results="asis"}
library(knitr)
degdir <- paste(params["outdir"], "DEGs", sep="/")
if(!dir.exists(degdir)) {
    print("There were no groups defined, so there are no differentially expressed genes.")
} else {
    deg_files <- list.files(degdir, full.names=TRUE)
    if(length(deg_files) == 0) {
        print("There were no groups defined, so there are no differentially expressed genes.")
    } else {
        gene_names <- read.table(paste(params["outdir"], "gene_id_gene_name_map.txt", sep="/"), header=FALSE)
        names(gene_names) <- c("EnsemblID", "GeneName")
        for(i in 1:length(deg_files)) {
            curr_f <- deg_files[i]
            fname <- basename(curr_f)
            gps <- unlist(strsplit(fname, "_"))[2]
            d <- read.table(curr_f, header=TRUE)
            d_g <- merge(d, gene_names, by.x="genes", by.y="EnsemblID")
            d_g <- d_g[order(d_g$FDR),]
            if(nrow(d_g) < 10) {
                lim <- nrow(d_g)
            } else {
                lim <- 10
            }
            print(kable(d_g[1:lim,], caption=paste("Top 10 DEGs at the 0.05 FDR for ", gps, sep="")))
        }
    }
}
```

# Run Summary
## General Workflow
### Read QC
A subsample of 10,000 reads or read pairs were sampled from each sample's reads.
This subsample of 10,000 reads was searched for contamination from ribosomal
RNA using a representative rRNA sequence list from the SILVA database release
132. Raw reads were summarized with FastQC, and optionally trimmed with
Trimmomatic. If trimmed, the cleaned reads are re-assessed with FastQC. Length,
quality, and duplication metrics were extracted from each FastQC run.

### Alignment
Trimmed reads (or raw reads, if `--no-trim` was specified) were aligned to the
reference genome with HISAT2. Duplicate reads based on alignment position were
marked with SAMTools. If `--rmdup` was specified, then the positional duplicates
were removed instead of marked. Alignments with duplicates marked were
summarized with RNASeQC to quantify the proportion of positional duplicates,
identify risosomal alignments, and quantify the proportion of "on-target"
reads. Processed alignments were filtered of reads that have a mapping quality
of less than 60, and sorted by query name rather than position.

### Counts and Differential Expression testing
Cleaned and name-sorted alignments were processed with the featureCounts tool
from the subread package. Fragments were counted in a strand-specific manner,
unless the `--strand U` option was passed for a library that was prepared in
a strand-unspecific way. Both mates of a read pair were required to map to a
feature to be counted, if the data were paired-end.

Raw counts were imported into the `edgeR` package in R. Gnees that are shorter
than the specified minimum length (`--min-len` argument, default 200bp) were
pruned from the counts matrix before differential expression testing. If
experimental groups were specified (`-e` argument), then the differential
expression testing was peformed with a quasi-likelihood test in `edgeR` between
all pairwise combinations of groups. A 0.05 false discovery rate correction
was applied to the tests.

## Results and Intermediate Files
### Output Directory
The output directory is located at

``r params["outdir"]``

This directory contains final results files and log files for the pipeline. Be
sure to save these files if you would like to keep them. However, the pipeline
script and samplesheet (reproduced below) are sufficient to recreate all output
files. It will just require additional compute time and service units. The
following directories are of interest:

- ``r paste(params["outdir"], "Counts", sep="/")``

    Contains raw and CPM-transformed counts for each gene in the supplied GTF
    annotation.

- ``r paste(params["outdir"], "DEGs", sep="/")``

    Contains a list of significantly differentially expressed genes, if
    experimental groups were supplied. If differential expression analysis was
    conducted, but no genes passed thresholds for significance, then the files
    will only have a header. Pairwise combinations of groups are tested for
    significance, so this directory may contain multiple files.

- ``r paste(params["outdir"], "Coordinate_Sorted_BAMs", sep="/")``

    Contains BAM alignments sorted on alignment coordinates and BAM index files
    for loading into IGV or other alignment visualization tools. There are both
    pre-filtered (`*markdup.bam` or `*rmdup.bam`) and post-filtered
    (`*Filtered_CoordSort.bam`) files. In this case, the filtering is performed
    on mapping quality.

- ``r paste(params["outdir"], "Dup_Stats", sep="/")``

    Contains per-read (2 files per sample for paired-end data) summaries of
    duplication levels in *raw* reads. These are extracted directly from the
    FastQC data file.

- ``r paste(params["outdir"], "RNASeqMetrics", sep="/")``

    Contains per-sample output files from Picard CollectRnaSeqMetrics from the
    pre-filtering BAM file. There are also per-sample metaplots of coverage
    bias across the transcripts.

- ``r paste(params["outdir"], "InsertSizeMetrics", sep="/")``

    Contains per-sample insert size summaries from Picard tools. The mean,
    median, and standard deviation are summarized in a table in the "Alignment
    Summaries" section of this report.

- ``r paste(params["outdir"], "Logs", sep="/")``

    Contains per-sample run logs for read QC, trimming, and alignment. Also
    contains a log file for counting reads and performing differential
    expression testing.

- ``r paste(params["outdir"], "Plots", sep="/")``

    Contains PDF vector images of DEG testing summary plots. The plots are also
    embedded into the "Counts Summaries" subsection of the "Alignment Summaries"
    section of this report.

### Work Directory
The work directory is located at

``r params["workdir"]``

This directory contains intermediate files for the pipeline. Be sure to save
these files if you would like to refer to them in the future. However, the
pipeline script and samplesheet (reproduced below) are sufficient to recreate
all intermediate files for the pipeline. The work directory contains the
following:

- ``r paste(params["workdir"], "allsamples", sep="/")``

    Summary files used to generate this report and final BAM files used for
    generating raw counts.

- ``r paste(params["workdir"], "singlesamples", sep="/")``

    Sub-directories, one for each sample, with FastQC reports, trimmed reads,
    intermediate SAM and BAM files, and alignment summary files. Refer to these
    if you would like to see the details of one particular sample. For example,
    if one sample has unexpected expression values, it may be because the
    sample is of low quality; this would be apparent in the read quality reports
    and the alignment summaries that are found in its work directory.

## Pipeline Script
The path to the pipeline script is ``r params["pipeline"]``

The pipeline script is printed below. You may copy and paste the following
script into a new plain text document to recreate the analyses run here. Be sure
to save it with UNIX line endings (`LF` rather than `CR` [Mac] or `CRLF`
[Windows] line endings), or else it will cause errors on Mesabi. Also be sure to
turn off "smart quotes" and "smart dashes" on any text editors that you use to
paste the following script. Smart quotes and smart dashes are not interpreted
correctly by the shell on Mesabi and will also cause errors.

<details><summary>

**Click to show pipeline script**

</summary>
```{bash pipeline_script, echo=FALSE, comment=NA}
cat $pipeline
```
</details>

## Samplesheet
The path to the samplesheet is ``r params["samplesheet"]``

The samplesheet is printed below, verbatim. It is cumbersome to read, but you
may copy and paste it into a plain text document to recreate the analyses run
here. Like the pipeline script, be sure to save it with UNIX line endings
(`LF` rather than `CR` [Mac] or `CRLF` [Windows]). Be sure to disable "smart
quotes" and "smart dashes" on the text editor.

<details><summary>

**Click to show samplesheet**

</summary>

```{bash samplesheet, echo=FALSE, comment=NA}
cat $samplesheet
```

</details>

The raw samplesheet is difficult to read, so we will print out a readable
summary below:

```{r samplesheet_readable, echo=FALSE, message=FALSE}
library(knitr)
# Define an NA-robust function here
base_na <- function(x) {
    if(is.na(x)) {
        return("NA")
    } else {
        return(basename(x))
    }
}
# Change the full R1/R2 paths into basenames
sheet$V3 <- as.character(sapply(sheet$V3, base_na))
sheet$V4 <- as.character(sapply(sheet$V4, base_na))
# And the reference, too
sheet$V10 <- as.character(sapply(sheet$V10, base_na))
sheet$V13 <- as.character(sapply(sheet$V13, base_na))
# Drop the output and work directories, columns 5 and 6
sheet <- sheet[,-c(5, 6)]
# Make the names nice
names(sheet) <- c(
    "Sample Name",
    "Group",
    "R1",
    "R2",
    "Trim?",
    "Remove Dups?",
    "Trimmomatic Options",
    "Reference Genome",
    "HISAT2 Options",
    "Strand",
    "GTF Name")
sheet
```

## Software Environment {.tabset}
### Single Sample Job Modules
This is the full list of loaded modules for each single-sample job, which
includes read trimming and read mapping.

```{bash single_sample_modules, echo=FALSE, comment=NA}
log_name="${outdir}/Logs/${firstrun}_Analysis.log"
log_start=$(($(grep -m 1 -n '^#BEGIN_MODULE' "${log_name}" | head -n 1 | cut -f 1 -d ':') + 2))
log_end=$(($(grep -m 1 -n '^#END_MODULES' "${log_name}" | head -n 1 | cut -f 1 -d ':') - 1))
head -n "${log_end}" "${log_name}" | tail -n "+${log_start}"
```
### Summary Job Modules
This is the full list of loaded modules for the summary job, which includes
counting and differential expression testing.

```{bash summary_modules, echo=FALSE, comment=NA}
log_name="${outdir}/Logs/BulkRNASeq_Analysis.log"
log_start=$(($(grep -n -m 1 '^#BEGIN_MODULES' "${log_name}" | head -n 1 | cut -f 1 -d ':') + 2))
log_end=$(($(grep -n -m 1 '^#END_MODULES' "${log_name}" | head -n 1 | cut -f 1 -d ':') - 1))
head -n "${log_end}" "${log_name}" | tail -n "+${log_start}"
```

# QC Metrics
## Read Counts
```{r read_counts, echo=FALSE, message=FALSE}
library(knitr)
names(read_summary) <- c(
    "Sample Name",
    "Raw R1 Count",
    "Raw R2 Count",
    "Trimmed R1 Count",
    "Trimmed R2 Count")
kable(read_summary, caption="Read count summary.")
```

## rRNA Contamination (Based on Kmer Matching) {.tabset}
These counts were based on searching a subset of the raw reads against a
reference database of ribosomal K-mers. Click on the table headers to show the
summaries of rRNA contamination.

```{r bbduk_plot, echo=FALSE, message=FALSE, results="asis"}
plt_dat <- as.numeric(gsub("%", "", as.character(bbduk_summary$rRNA_Pct))) / 100
if(large_dataset) {
    cat("### Plots {.tabset}\n")
    for(i in unique(chunks)) {
        idx <- which(chunks == i)
        subdat <- plt_dat[idx]
        cat("#### Samples ", idx[1], " to ", idx[length(idx)], "\n")
        at <- barplot(
            subdat,
            col="#e41a1c",
            ylim=c(0, 0.75),
            xlab="",
            ylab="Proportion rRNA",
            main="K-mer Based rRNA Contamination",
            axes=FALSE)
        axis(side=1, at=at, labels=as.character(bbduk_summary$SampleName)[idx], las=2, cex.axis=0.6)
        axis(side=2, at=seq(0, 0.6, by=0.05), labels=seq(0, 0.6, by=0.05))
        rect(
            xleft=par("usr")[1],
            xright=par("usr")[2],
            ybottom=0.2,
            ytop=0.35,
            col=rgb(255/255, 237/255, 160/255, 0.5),
            border=NA
            )
        rect(
            xleft=par("usr")[1],
            xright=par("usr")[2],
            ybottom=0.35,
            ytop=0.6,
            col=rgb(228/255, 26/255, 28/255, 0.25),
            border=NA
            )
        # Dumb, but re-plot it to put it on the top
        barplot(
            subdat,
            col="#e41a1c",
            ylim=c(0, 0.75),
            xlab="",
            ylab="Proportion rRNA",
            main="K-mer Based rRNA Contamination",
            axes=FALSE,
            add=TRUE)
        cat("\n\n")
    }
} else {
    cat("### Plot\n")
    at <- barplot(
        plt_dat,
        col="#e41a1c",
        ylim=c(0, 0.75),
        xlab="",
        ylab="Proportion rRNA",
        main="K-mer Based rRNA Contamination",
    axes=FALSE)
    axis(side=1, at=at, labels=as.character(bbduk_summary$SampleName), las=2, cex.axis=0.6)
    axis(side=2, at=seq(0, 0.6, by=0.05), labels=seq(0, 0.6, by=0.05))
    rect(
        xleft=par("usr")[1],
        xright=par("usr")[2],
        ybottom=0.2,
        ytop=0.35,
        col=rgb(255/255, 237/255, 160/255, 0.5),
        border=NA
        )
    rect(
        xleft=par("usr")[1],
        xright=par("usr")[2],
        ybottom=0.35,
        ytop=0.6,
        col=rgb(228/255, 26/255, 28/255, 0.25),
        border=NA
        )
    # Dumb, but re-plot it to put it on the top
    barplot(
        plt_dat,
        col="#e41a1c",
        ylim=c(0, 0.75),
        xlab="",
        ylab="Proportion rRNA",
        main="K-mer Based rRNA Contamination",
        axes=FALSE,
        add=TRUE)
}
```

### Table
```{r bbduk_table, echo=FALSE, message=FALSE}
library(knitr)
kable(bbduk_summary, caption="Number of read pairs (from subsample) and percentage of library that is estimated to be derived from ribosomal RNA.")
```

## Mapping-based QC Metrics {.tabset}
These plots show QC metrics based on summaries of the BAM alignment files, as
generated by [RNASeQC](https://github.com/broadinstitute/rnaseqc).

### Expression Profiling Efficiency
This plot shows the proportion of high-quality alignments that are in exons. For
messenger RNA libraries, this value is expected to be close to 1.

```{r epe_plot, echo=FALSE, message=FALSE, fig.width=8, fig.height=min(3.6, 0.4*lg_cutoff), results="asis"}
par(mar=c(4, 4, 5, 1), mgp=c(2.5, 0.75, 0))
epe_dat <- as.numeric(rnaseqc_summary$Value[rnaseqc_summary$Statistic == "Expression Profiling Efficiency"])
if(large_dataset) {
    cat("#### Plots {.tabset}\n")
    for(i in unique(chunks)) {
        idx <- which(chunks == i)
        subdat <- epe_dat[idx]
        cat("##### Samples ", idx[1], " to ", idx[length(idx)], "\n")
        at <- barplot(
            subdat,
            axes=FALSE,
            horiz=TRUE,
            xlim=c(0, 1),
            xlab="Efficiency",
            main="Expression Profiling Efficiency",
            ylab="",
            col="#1f78b4")
        axis(side=2, at=at, labels=as.character(unique(rnaseqc_summary$SampleName))[idx], las=2, cex.axis=0.6, lty=0)
        axis(side=1)
        axis(side=3)
        cat("\n\n")
    }
} else {
    at <- barplot(
        epe_dat,
        axes=FALSE,
        horiz=TRUE,
        xlim=c(0, 1),
        xlab="Efficiency",
        main="Expression Profiling Efficiency",
        ylab="",
        col="#1f78b4")
    axis(side=2, at=at, labels=as.character(unique(rnaseqc_summary$SampleName)), las=2, cex.axis=0.6, lty=0)
    axis(side=1)
    axis(side=3)
}
```

### Duplication
This plot shows the proportion of alignments that are positional duplicates in
each sample, as determined in the default algorithm of the
[Picard MarkDuplicates](https://broadinstitute.github.io/picard/command-line-overview.html#MarkDuplicates) tool.

```{r dup_plot, echo=FALSE, message=FALSE, fig.width=8, fig.height=min(3.6, 0.4*lg_cutoff), results="asis"}
par(mar=c(4, 4, 5, 1), mgp=c(2.5, 0.75, 0))
dup_dat <- as.numeric(rnaseqc_summary$Value[rnaseqc_summary$Statistic == "Duplicate Rate of Mapped"])
if(large_dataset) {
    cat("#### Plots {.tabset}\n")
    for(i in unique(chunks)) {
        idx <- which(chunks == i)
        subdat <- dup_dat[idx]
        cat("##### Samples ", idx[1], " to ", idx[length(idx)], "\n")
        at <- barplot(
            subdat,
            axes=FALSE,
            horiz=TRUE,
            xlim=c(0, 1),
            xlab="Proportion of Fragments",
            main="Sequence Duplication Levels",
            ylab="",
            col="#1f78b4")
        axis(side=2, at=at, labels=as.character(unique(rnaseqc_summary$SampleName))[idx], las=2, cex.axis=0.6, lty=0)
        axis(side=1)
        axis(side=3)
        cat("\n\n")
    }
} else {
    at <- barplot(
        dup_dat,
        axes=FALSE,
        horiz=TRUE,
        xlim=c(0, 1),
        xlab="Proportion of Fragments",
        main="Sequence Duplication Levels",
        ylab="",
        col="#1f78b4")
    axis(side=2, at=at, labels=as.character(unique(rnaseqc_summary$SampleName)), las=2, cex.axis=0.6, lty=0)
    axis(side=1)
    axis(side=3)
}
```

### gDNA and Strand Agreement
These plots show both gDNA contamination and strand-specificity. The plot on
the left shows the read alignments to exons, introns, and to intergenic regions
while accounting for the strand of the annotations. The plot on the right shows
the same region-based summary, but ignoring the strand of the annotations. If
the unstranded plot shows much higher assignment to exons than the strand-aware
plot, then it is likely that you have given the incorrect strand-specificity
for your library. Please refer to the library preparation protocol to determine
the correct strand-specificity.

If the plots look similar in terms of assignment proportions, then you have
given the correct strand-specificity.

```{r gdna_plot, echo=FALSE, message=FALSE, fig.width=8, fig.height=min(4.8, 0.6*lg_cutoff), results="asis"}
par(mar=c(4, 4, 5, 1), mgp=c(2.5, 0.75, 0), mfrow=c(1, 2))
gdna_dat <- matrix(
    c(
        as.numeric(rnaseqc_summary$Value[rnaseqc_summary$Statistic == "Exonic Rate"]),
        as.numeric(rnaseqc_summary$Value[rnaseqc_summary$Statistic == "Intronic Rate"]),
        as.numeric(rnaseqc_summary$Value[rnaseqc_summary$Statistic == "Intergenic Rate"])
        ),
    byrow=TRUE,
    nrow=3
    )
gdna_dat_uns <- matrix(
    c(
        as.numeric(rnaseqc_summary_uns$Value[rnaseqc_summary_uns$Statistic == "Exonic Rate"]),
        as.numeric(rnaseqc_summary_uns$Value[rnaseqc_summary_uns$Statistic == "Intronic Rate"]),
        as.numeric(rnaseqc_summary_uns$Value[rnaseqc_summary_uns$Statistic == "Intergenic Rate"])
        ),
    byrow=TRUE,
    nrow=3
    )
bar_cols <- c("#a6cee3", "#1f78b4", "#b2df8a")

if(large_dataset) {
    cat("#### Plots {.tabset}\n")
    for(i in unique(chunks)) {
        idx <- which(chunks == i)
        subdat <- gdna_dat[,idx]
        subdat_uns <- gdna_dat_uns[,idx]
        cat("##### Samples ", idx[1], " to ", idx[length(idx)], "\n")
        at <- barplot(
            subdat,
            beside=TRUE,
            axes=FALSE,
            horiz=TRUE,
            xlim=c(0, 1.25),
            xlab="Proportion of Fragments",
            main="Strand-aware Metrics",
            ylab="",
            col=bar_cols)
        axis(side=2, at=apply(at, 2, mean), labels=as.character(unique(rnaseqc_summary$SampleName))[idx], las=2, cex.axis=0.6, lty=0)
        axis(side=1)
        axis(side=3)
        legend("right", c("Exon", "Intron", "Intergenic"), fill=bar_cols, ncol=1, cex=0.8)

        at <- barplot(
            subdat_uns,
            beside=TRUE,
            axes=FALSE,
            horiz=TRUE,
            xlim=c(0, 1.25),
            xlab="Proportion of Fragments",
            main="Unstranded Metrics",
            ylab="",
            col=bar_cols)
        axis(side=2, at=apply(at, 2, mean), labels=as.character(unique(rnaseqc_summary$SampleName))[idx], las=2, cex.axis=0.6, lty=0)
        axis(side=1)
        axis(side=3)
        legend("right", c("Exon", "Intron", "Intergenic"), fill=bar_cols, ncol=1, cex=0.8)
        cat("\n\n")
    }
} else {
    at <- barplot(
        gdna_dat,
        beside=TRUE,
        axes=FALSE,
        horiz=TRUE,
        xlim=c(0, 1.25),
        xlab="Proportion of Fragments",
        main="Strand-aware Metrics",
        ylab="",
        col=bar_cols)
    axis(side=2, at=apply(at, 2, mean), labels=as.character(unique(rnaseqc_summary$SampleName)), las=2, cex.axis=0.6, lty=0)
    axis(side=1)
    axis(side=3)
    legend("right", c("Exon", "Intron", "Intergenic"), fill=bar_cols, ncol=1, cex=0.8)

    at <- barplot(
        gdna_dat_uns,
        beside=TRUE,
        axes=FALSE,
        horiz=TRUE,
        xlim=c(0, 1.25),
        xlab="Proportion of Fragments",
        main="Unstranded Metrics",
        ylab="",
        col=bar_cols)
    axis(side=2, at=apply(at, 2, mean), labels=as.character(unique(rnaseqc_summary$SampleName)), las=2, cex.axis=0.6, lty=0)
    axis(side=1)
    axis(side=3)
    legend("right", c("Exon", "Intron", "Intergenic"), fill=bar_cols, ncol=1, cex=0.8)
}
```

### rRNA
This plot shows the proportion of alignments that are in annotated rRNA features.

```{r rrna_map_plot, echo=FALSE, message=FALSE, fig.width=8, fig.height=min(3.6, 0.4*lg_cutoff), results="asis"}
par(mar=c(4, 4, 5, 1), mgp=c(2.5, 0.75, 0))
rrna_dat <- as.numeric(rnaseqc_summary$Value[rnaseqc_summary$Statistic == "rRNA Rate"])
if(large_dataset) {
    cat("#### Plots {.tabset}\n")
    for(i in unique(chunks)) {
        idx <- which(chunks == i)
        subdat <- rrna_dat[idx]
        cat("##### Samples ", idx[1], " to ", idx[length(idx)], "\n")
        at <- barplot(
            subdat,
            axes=FALSE,
            horiz=TRUE,
            xlim=c(0, 1),
            xlab="Proportion of Fragments",
            main="rRNA Mapping Rate",
            ylab="",
            col="#e41a1c")
        axis(side=2, at=at, labels=as.character(unique(rnaseqc_summary$SampleName))[idx], las=2, cex.axis=0.6, lty=0)
        axis(side=1)
        axis(side=3)
        cat("\n\n")
    }
} else {
    at <- barplot(
        rrna_dat,
        axes=FALSE,
        horiz=TRUE,
        xlim=c(0, 1),
        xlab="Proportion of Fragments",
        main="rRNA Mapping Rate",
        ylab="",
        col="#e41a1c")
    axis(side=2, at=at, labels=as.character(unique(rnaseqc_summary$SampleName)), las=2, cex.axis=0.6, lty=0)
    axis(side=1)
    axis(side=3)
}
```

## Read Qualities {.tabset}
Click on the tab headers to show plots of raw and trimmed read qualities.

### Raw Read Qualities (Compact style)
These plots show the read qualities as they came off the sequencing instrument.

```{r raw_read_quals, echo=FALSE, message=FALSE, fig.width=8, fig.height=min(0.7*nrow(sheet), 0.7*lg_cutoff), results="asis"}
plotqual_first <- function(sn) {
    allquals <- matrix(0:45)
    image(
        allquals,
        breaks=c(0, 10, 20, 25, 30, 40, 45),
        col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
        axes=FALSE,
        main="Quality Key")
    axis(side=1, at=seq(0, 1, length.out=46)[c(TRUE, FALSE)], labels=as.character(0:45)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)

    plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
    qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_1.raw_quals.txt", sep=""), sep="/")
    dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
    names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
    # Make a plot
    image(
        as.matrix(dat$QMean),
        breaks=c(0, 10, 20, 25, 30, 40, 45),
        col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
        axes=FALSE,
        main="Mean R1 Quality")
    mtext(side=2, font=2, cex=0.5, las=2, sn)
    qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_2.raw_quals.txt", sep=""), sep="/")
    if(!file.exists(qr2_file)) {
        plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
        text(x=0.5, y=0.5, "No R2", cex=1, col="black")
    } else{
        dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE,
            main="Mean R2 Quality")
    }
}

plotqual <- function(sn) {
    qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_1.raw_quals.txt", sep=""), sep="/")
    dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
    names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
    # Make a plot
    image(
        as.matrix(dat$QMean),
        breaks=c(0, 10, 20, 25, 30, 40, 45),
        col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
        axes=FALSE)
    mtext(side=2, font=2, cex=0.5, las=2, sn)
    qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_2.raw_quals.txt", sep=""), sep="/")
    if(!file.exists(qr2_file)) {
        plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
        text(x=0.5, y=0.5, "No R2", cex=1, col="black")
    } else{
        dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE)
    }
}

plotqual_last <- function(sn) {
    qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_1.raw_quals.txt", sep=""), sep="/")
    dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
    names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
    # Make a plot
    image(
        as.matrix(dat$QMean),
        breaks=c(0, 10, 20, 25, 30, 40, 45),
        col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
        axes=FALSE)
    mtext(side=2, font=2, cex=0.5, las=2, sn)
    axis(side=1, at=seq(0, 1, length.out=nrow(dat))[c(TRUE, FALSE)], labels=as.character(dat$Base)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)
    qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_2.raw_quals.txt", sep=""), sep="/")
    if(!file.exists(qr2_file)) {
        plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
        text(x=0.5, y=0.5, "No R2", cex=1, col="black")
    } else{
        dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
        dat$X <- 1:nrow(dat)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE)
        axis(side=1, at=seq(0, 1, length.out=nrow(dat))[c(TRUE, FALSE)], labels=as.character(dat$Base)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)
    }
}

if(large_dataset) {
    cat("#### Plots {.tabset}\n")
    for(i in unique(chunks)) {
        idx <- which(chunks == i)
        cat("##### Samples ", idx[1], " to ", idx[length(idx)], "\n")
        subsamp <- samplenames[idx]
        nsubsamp <- length(subsamp)
        cat("\n\n")
        par(mfrow=c(nsubsamp+1, 2))
        # Set the margins of the top to be high on the first two so we can add the R1/R2 labels
        par(mar=c(1.1, 5, 1.1, 0.1), mgp=c(1.25, 0.15, 0))
        dummy <- plotqual_first(subsamp[1])
        par(mar=c(1.1, 5, 1.1, 0.1))
        dummy <- sapply(subsamp[3:nsubsamp-1], plotqual)
        par(mar=c(2.5, 5, 0.1, 0.1), mgp=c(1.25, 0.15, 0))
        dummy <- plotqual_last(subsamp[nsubsamp])
        cat("\n\n")
    }
} else {
    par(mfrow=c(nsamp+1, 2))
    # Set the margins of the top to be high on the first two so we can add the R1/R2 labels
    par(mar=c(1.1, 5, 1.1, 0.1), mgp=c(1.25, 0.15, 0))
    dummy <- plotqual_first(samplenames[1])
    par(mar=c(1.1, 5, 1.1, 0.1))
    dummy <- sapply(samplenames[3:nsamp-1], plotqual)
    par(mar=c(2.5, 5, 0.1, 0.1), mgp=c(1.25, 0.15, 0))
    dummy <- plotqual_last(samplenames[nsamp])
}
```

### Trimmed Read Qualities (Compact style)
These plots show read qualities post-trimming, if it was performed.

```{r trim_read_quals, echo=FALSE, message=FALSE, fig.width=8, fig.height=min(0.7*nrow(sheet), 0.7*lg_cutoff), results="asis"}
if(length(trim_samp) > 0) {
    plotqual_first <- function(sn) {
        allquals <- matrix(0:45)
        image(
            allquals,
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE,
            main="Quality Key")
        axis(side=1, at=seq(0, 1, length.out=46)[c(TRUE, FALSE)], labels=as.character(0:45)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)

        plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
        qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_1.trim_quals.txt", sep=""), sep="/")
        dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        # Make a plot
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE,
            main="Mean R1 Quality")
        mtext(side=2, font=2, cex=0.5, las=2, sn)
        qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_2.trim_quals.txt", sep=""), sep="/")
        if(!file.exists(qr2_file)) {
            plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
            text(x=0.5, y=0.5, "No R2", cex=1, col="black")
        } else{
            dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
            names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
            image(
                as.matrix(dat$QMean),
                breaks=c(0, 10, 20, 25, 30, 40, 45),
                col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
                axes=FALSE,
                main="Mean R2 Quality")
        }
    }

    plotqual <- function(sn) {
        qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_1.trim_quals.txt", sep=""), sep="/")
        dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        # Make a plot
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE)
        mtext(side=2, font=2, cex=0.5, las=2, sn)
        qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_2.trim_quals.txt", sep=""), sep="/")
        if(!file.exists(qr2_file)) {
            plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
            text(x=0.5, y=0.5, "No R2", cex=1, col="black")
        } else{
            dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
            names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
            image(
                as.matrix(dat$QMean),
                breaks=c(0, 10, 20, 25, 30, 40, 45),
                col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
                axes=FALSE)
        }
    }

    plotqual_last <- function(sn) {
        qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_1.trim_quals.txt", sep=""), sep="/")
        dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        # Make a plot
        image(
            as.matrix(dat$QMean),
            breaks=c(0, 10, 20, 25, 30, 40, 45),
            col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
            axes=FALSE)
        mtext(side=2, font=2, cex=0.5, las=2, sn)
        axis(side=1, at=seq(0, 1, length.out=nrow(dat))[c(TRUE, FALSE)], labels=as.character(dat$Base)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)
        qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_2.trim_quals.txt", sep=""), sep="/")
        if(!file.exists(qr2_file)) {
            plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
            text(x=0.5, y=0.5, "No R2", cex=1, col="black")
        } else{
            dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
            dat$X <- 1:nrow(dat)
            names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
            image(
                as.matrix(dat$QMean),
                breaks=c(0, 10, 20, 25, 30, 40, 45),
                col=c("darkred", "indianred", "yellow", "gold", "darkgreen", "green"),
                axes=FALSE)
            axis(side=1, at=seq(0, 1, length.out=nrow(dat))[c(TRUE, FALSE)], labels=as.character(dat$Base)[c(TRUE, FALSE)], las=2, cex.axis=0.75, tck=-0.05)
        }
    }
    if(large_dataset) {
        cat("#### Plots {.tabset}\n")
        for(i in unique(chunks)) {
            idx <- which(chunks == i)
            cat("##### Samples ", idx[1], " to ", idx[length(idx)], "\n")
            subsamp <- trim_samp[idx]
            nsubsamp <- length(subsamp)
            cat("\n\n")
            par(mfrow=c(nsubsamp+1, 2))
            # Set the margins of the top to be high on the first two so we can add the R1/R2 labels
            par(mar=c(1.1, 5, 1.1, 0.1), mgp=c(1.25, 0.15, 0))
            dummy <- plotqual_first(subsamp[1])
            par(mar=c(1.1, 5, 1.1, 0.1))
            dummy <- sapply(subsamp[3:nsubsamp-1], plotqual)
            par(mar=c(2.5, 5, 0.1, 0.1), mgp=c(1.25, 0.15, 0))
            dummy <- plotqual_last(subsamp[nsubsamp])
            cat("\n\n")
        }
    } else {
        par(mfrow=c(nsamp+1, 2))
        # Set the margins of the top to be high on the first two so we can add the R1/R2 labels
        par(mar=c(1.1, 5, 1.1, 0.1), mgp=c(1.25, 0.15, 0))
        dummy <- plotqual_first(trim_samp[1])
        par(mar=c(1.1, 5, 1.1, 0.1))
        dummy <- sapply(trim_samp[3:nsamp-1], plotqual)
        par(mar=c(2.5, 5, 0.1, 0.1), mgp=c(1.25, 0.15, 0))
        dummy <- plotqual_last(trim_samp[nsamp])
    }
} else {
        cat("\nNo trimming performed.")
    }
```

### Raw Read Qualities (FastQC-style)
The plots below show the variance in quality across the reads for each sample.
The black dot shows the mean quality, the red dot shows the median quality,
the grey shaded region shows the inter-quartile range, and the vertical black
lines show the 10th-90th percentile range.

```{r raw_read_quals_fastqc, echo=FALSE, message=FALSE, fig.width=8, fig.height=min(1.7*nrow(sheet), 1.7*lg_cutoff), results="asis"}
plotqual <- function(sn) {
    qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_1.raw_quals.txt", sep=""), sep="/")
    dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
    names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
    # Make a dummy variable for position because some of the classes are binned
    dat$X <- 1:nrow(dat)
    # Make a plot
    plot(dat$QMean ~ dat$X, type="n", xlab="Position in Read", ylab="Quality", axes=F, ylim=c(0, 45))
    segments(x0=dat$X, y1=dat$Q10, y0=dat$Q90, lwd=1, col="black")
    segments(x0=dat$X, y1=dat$Q25, y0=dat$Q75, lwd=8, col="grey")
    points(dat$QMean ~ dat$X, pch=19, col="black", cex=0.75)
    points(dat$QMedian ~ dat$X, pch=19, col="red", cex=0.75)
    axis(side=2)
    axis(side=1, at=dat$X[c(TRUE, FALSE)], labels=dat$Base[c(TRUE, FALSE)], las=2, cex.axis=0.75)
    title(paste(sn, "R1", sep=" "))
    qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_2.raw_quals.txt", sep=""), sep="/")
    if(!file.exists(qr2_file)) {
        plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
        text(x=0.5, y=0.5, "No R2 file found.", cex=1.5, col="black")
    } else{
        dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        # Make a dummy variable for position because some of the classes are binned
        dat$X <- 1:nrow(dat)
        # Make a plot
        plot(dat$QMean ~ dat$X, type="n", xlab="Position in Read", ylab="Quality", axes=F, ylim=c(0, 45))
        segments(x0=dat$X, y1=dat$Q10, y0=dat$Q90, lwd=1, col="black")
        segments(x0=dat$X, y1=dat$Q25, y0=dat$Q75, lwd=8, col="grey")
        points(dat$QMean ~ dat$X, pch=19, col="black", cex=0.75)
        points(dat$QMedian ~ dat$X, pch=19, col="red", cex=0.75)
        axis(side=2)
        axis(side=1, at=dat$X[c(TRUE, FALSE)], labels=dat$Base[c(TRUE, FALSE)], las=2, cex.axis=0.75)
        title(paste(sn, "R2", sep=" "))
    }
}
if(large_dataset) {
    par(mfrow=c(lg_cutoff, 2), mar=c(4, 3.5, 1, 0), mgp=c(2.5, 0.75, 0))
    cat("#### Plots {.tabset}\n")
    for(i in unique(chunks)) {
        idx <- which(chunks == i)
        cat("##### Samples ", idx[1], " to ", idx[length(idx)], "\n")
        subsamp <- samplenames[idx]
        plt_out <- sapply(subsamp, plotqual)
        cat("\n\n")
    }
} else {
    par(mfrow=c(nsamp, 2), mar=c(4, 3.5, 1, 0), mgp=c(2.5, 0.75, 0))
    plt_out <- sapply(samplenames, plotqual)
}
```

### Trimmed Read Qualities (FastQC-style)
The plots below show the variance in quality across the reads for each sample.
The black dot shows the mean quality, the red dot shows the median quality,
the grey shaded region shows the inter-quartile range, and the vertical black
lines show the 10th-90th percentile range.

```{r trim_read_quals_fastqc, echo=FALSE, message=FALSE, fig.width=8, fig.height=min(1.7*nrow(sheet), 1.7*lg_cutoff), results="asis"}
if(length(trim_samp) > 0) {
    plotqual <- function(sn) {
        qr1_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_1.trim_quals.txt", sep=""), sep="/")
        dat <- read.table(qr1_file, header=F, stringsAsFactors=FALSE)
        names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
        # Make a dummy variable for position because some of the classes are binned
        dat$X <- 1:nrow(dat)
        # Make a plot
        plot(dat$QMean ~ dat$X, type="n", xlab="Position in Read", ylab="Quality", axes=F, ylim=c(0, 45))
        segments(x0=dat$X, y1=dat$Q10, y0=dat$Q90, lwd=1, col="black")
        segments(x0=dat$X, y1=dat$Q25, y0=dat$Q75, lwd=8, col="grey")
        points(dat$QMean ~ dat$X, pch=19, col="black", cex=0.75)
        points(dat$QMedian ~ dat$X, pch=19, col="red", cex=0.75)
        axis(side=2)
        axis(side=1, at=dat$X[c(TRUE, FALSE)], labels=dat$Base[c(TRUE, FALSE)], las=2, cex.axis=0.75)
        title(paste(sn, "R1", sep=" "))
        qr2_file <- paste(params["workdir"], "singlesamples", sn, paste(sn, "_2.trim_quals.txt", sep=""), sep="/")
        if(!file.exists(qr2_file)) {
            plot(c(0, 1), c(0, 1), ann=F, bty="n", type="n", xaxt="n", yaxt="n")
            text(x=0.5, y=0.5, "No R2 file found.", cex=1.5, col="black")
        } else{
            dat <- read.table(qr2_file, header=F, stringsAsFactors=FALSE)
            names(dat) <- c("Base", "QMean", "QMedian", "Q25", "Q75", "Q10", "Q90")
            # Make a dummy variable for position because some of the classes are binned
            dat$X <- 1:nrow(dat)
            # Make a plot
            plot(dat$QMean ~ dat$X, type="n", xlab="Position in Read", ylab="Quality", axes=F, ylim=c(0, 45))
            segments(x0=dat$X, y1=dat$Q10, y0=dat$Q90, lwd=1, col="black")
            segments(x0=dat$X, y1=dat$Q25, y0=dat$Q75, lwd=8, col="grey")
            points(dat$QMean ~ dat$X, pch=19, col="black", cex=0.75)
            points(dat$QMedian ~ dat$X, pch=19, col="red", cex=0.75)
            axis(side=2)
            axis(side=1, at=dat$X[c(TRUE, FALSE)], labels=dat$Base[c(TRUE, FALSE)], las=2, cex.axis=0.75)
            title(paste(sn, "R2", sep=" "))
        }
    }
    if(large_dataset) {
        par(mfrow=c(lg_cutoff, 2), mar=c(4, 3.5, 1, 0), mgp=c(2.5, 0.75, 0))
        cat("#### Plots {.tabset}\n")
        for(i in unique(chunks)) {
            idx <- which(chunks == i)
            cat("##### Samples ", idx[1], " to ", idx[length(idx)], "\n")
            subsamp <- trim_samp[idx]
            plt_out <- sapply(subsamp, plotqual)
            cat("\n\n")
        }
    } else {
        par(mfrow=c(nsamp, 2), mar=c(4, 3.5, 1, 0), mgp=c(2.5, 0.75, 0))
        plt_out <- sapply(trim_samp, plotqual)
    }
} else {
    cat("No trimming performed.")
}
```

# Alignment Summaries
## HISAT2 Summaries {.tabset}
### Counts-Based
These plots summarize the number of fragments that align uniquely, multiply,
discordantly, or do not map to the genome.

```{r hisat2_counts, echo=FALSE, message=FALSE, results="asis"}
library(knitr)

count_dat <- as.matrix(hisat_summary[,c("UniqueMapped", "MultiMapped", "DiscoMapped", "Unmapped")])
max_reads <- max(hisat_summary$Total)/1000000
if(large_dataset) {
    cat("#### Plots {.tabset}\n")
    for(i in unique(chunks)) {
        idx <- which(chunks == i)
        cat("##### Samples ", idx[1], " to ", idx[length(idx)], "\n")
        subdat <- count_dat[idx,]
        at <- barplot(
            t(subdat)/1000000,
            beside=FALSE,
            col=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
            ylim=c(0, max_reads*1.2),
            ylab="Fragment Count (Millions)",
            main="HISAT2 Count Plot",
            axes=FALSE)
        axis(side=2)
        axis(side=1, at=at, labels=as.character(hisat_summary$SampleName)[idx], cex.axis=0.6, las=2)
        legend(
            "top",
            c("Uniquely Mapped", "Multiply Mapped", "Discordantly Mapped", "Unmapped"),
            fill=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
            ncol=4,
            cex=0.7)
        cat("\n\n")
    }
} else {
    cat("#### Plot\n")
    at <- barplot(
        t(count_dat)/1000000,
        beside=FALSE,
        col=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
        ylim=c(0, max_reads*1.2),
        ylab="Fragment Count (Millions)",
        main="HISAT2 Count Plot",
        axes=FALSE)
        axis(side=2)
        axis(side=1, at=at, labels=as.character(hisat_summary$SampleName), cex.axis=0.6, las=2)
        legend(
            "top",
            c("Uniquely Mapped", "Multiply Mapped", "Discordantly Mapped", "Unmapped"),
            fill=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
            ncol=4,
            cex=0.7)
}

hisat_tab <- hisat_summary
names(hisat_tab) <- c("Sample Name", "Total Fragments", "Unmapped", "Uniquely Mapped", "Multiply Mapped", "Discordantly Mapped")
kable(hisat_tab, caption="Summary of alignment from HISAT2 based on fragment counts. Note that if the samples are paired-end, then each fragment is represented by 2 reads. If the samples are single-end, then each fragment is represented by 1 read.")
```

### Proportion-Based
These plots summarize the mapping as a proportion of the total reads.

```{r hisat2_prop, echo=FALSE, message=FALSE, results="asis"}
library(knitr)
# Then make a proportion plot
prop_dat <- count_dat / as.numeric(hisat_summary$Total)
if(large_dataset) {
    cat("#### Plots {.tabset}\n")
    for(i in unique(chunks)) {
        idx <- which(chunks == i)
        cat("##### Samples ", idx[1], " to ", idx[length(idx)], "\n")
        subdat <- prop_dat[idx,]
        at <- barplot(
            t(subdat),
            beside=FALSE,
            col=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
            ylim=c(0, 1.2),
            ylab="Proportion",
            main="HISAT2 Proportion Plot",
            axes=FALSE)
        axis(side=2)
        axis(side=1, at=at, labels=as.character(hisat_summary$SampleName)[idx], cex.axis=0.6, las=2)
        legend(
            "top",
            c("Uniquely Mapped", "Multiply Mapped", "Discordantly Mapped", "Unmapped"),
            fill=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
            ncol=4,
            cex=0.7)
        cat("\n\n")
    }
} else {
    cat("#### Plot\n")
    at <- barplot(
        t(prop_dat),
        beside=FALSE,
        col=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
        ylim=c(0, 1.2),
        ylab="Proportion",
        main="HISAT2 Proportion Plot",
        axes=FALSE)
        axis(side=2)
        axis(side=1, at=at, labels=as.character(hisat_summary$SampleName), cex.axis=0.6, las=2)
        legend(
            "top",
            c("Uniquely Mapped", "Multiply Mapped", "Discordantly Mapped", "Unmapped"),
            fill=c("#1f78b4", "#a6cee3", "#b2df8a", "#999999"),
            ncol=4,
            cex=0.7)
}

hisat_prop <- data.frame(
    SN=as.character(hisat_summary$SampleName),
    TO=rep("100%", nrow(hisat_summary)),
    UNM=paste(as.character(round((hisat_summary$Unmapped/hisat_summary$Total)*100, digits=2)), "%", sep=""),
    SM=paste(as.character(round((hisat_summary$UniqueMapped/hisat_summary$Total)*100, digits=2)), "%", sep=""),
    MM=paste(as.character(round((hisat_summary$MultiMapped/hisat_summary$Total)*100, digits=2)), "%", sep=""),
    DM=paste(as.character(round((hisat_summary$DiscoMapped/hisat_summary$Total)*100, digits=2)), "%", sep=""))
names(hisat_prop) <- c(
    "Sample Name",
    "Total Fragments",
    "Unmapped",
    "Uniquely Mapped",
    "Multiply Mapped",
    "Discordantly Mapped")
kable(hisat_prop, caption="Summary of alignment from HISAT2 based on percentage of total reads. Note that if the samples are paired-end, then each fragment is represented by 2 reads. If the samples are single-end, then each fragment is represented by 1 read.")
```

## Mapping Statistics
The following table summarizes alignment characteristics with the output from
`samtools stats`.

```{r map_stats, echo=FALSE, message=FALSE}
library(knitr)
mapping_summary <- read.table(paste(params["workdir"], "allsamples", "Samtools_Stats.txt", sep="/"), header=F)
names(mapping_summary) <- c(
    "Sample Name",
    "Reads Mapped*",
    "PCR Duplicate",
    "MAPQ = 0",
    "Max Read Length",
    "Average Read Length",
    "Average Read Quality")
kable(mapping_summary, caption="Summary of read mapping from SAMTools. *Note that this counts reads and not fragments.")
```

## Insert Size Metrics
The plot below shows the variance in insert size for each sample. The black dot
shows the mean insert size, the red dot shows the median insert size, the grey
shaded region shows the bin that encompasses 30% of the insert sizes, and the
black lines show the bin that encompasses 90% of the insert sizes.

The bin widths reported in the table are widths of intervals, centered around
the median, that encompass a certain percentage of the insert sizes. For a full
description of the bin widths, see the [Picard Documentation](https://broadinstitute.github.io/picard/picard-metric-definitions.html#InsertSizeMetrics).

```{r is_stats, echo=FALSE, message=FALSE}
library(knitr)
insertsize_file <- paste(params["workdir"], "allsamples", "IS_Stats.txt", sep="/")
if(!file.exists(insertsize_file)) {
    print("No insert size metrics found.")
} else {
    is_summary <- read.table(insertsize_file, header=F)
    # Calculate the widest interval that we would have to plot:
    # mean insert size + 1/2 of the 90% percentile bin
    lims <- is_summary$V3 + (is_summary$V8)/2
    max_is <- max(lims)
    plot(
        rep(0, nrow(is_summary)) ~ seq_along(is_summary$V1),
        type="n",
        xlab="",
        ylab="Insert Size (bp)",
        main="Insert Size Distribution",
        ylim=c(0, max_is*1.2),
        axes=FALSE)
    segments(x0=seq_along(is_summary$V1), y1=is_summary$V2-(is_summary$V8)/2, y0=is_summary$V2+(is_summary$V8)/2, lwd=1, col="black")
    segments(x0=seq_along(is_summary$V1), y1=is_summary$V2-(is_summary$V6)/2, y0=is_summary$V2+(is_summary$V6)/2, lwd=8, col="grey")
    points(is_summary$V3 ~ seq_along(is_summary$V1), pch=19, col="black", cex=0.75)
    points(is_summary$V2 ~ seq_along(is_summary$V1), pch=19, col="red", cex=0.75)
    axis(side=2)
    axis(side=1, at=seq_along(is_summary$V1), labels=is_summary$V1, las=2, cex.axis=0.75)

    is_summary$V3 <- round(is_summary$V3, 3)
    is_summary$V4 <- round(is_summary$V4, 3)
    names(is_summary) <- c(
        "Sample Name",
        "Median Insert Size",
        "Mean Insert Size",
        "Insert Size StdDev",
        "Width of 10% Bin",
        "Width of 30% Bin",
        "Width of 70% Bin",
        "Width of 90% Bin")
    kable(is_summary, caption="Insert size summary.")
}
```

## Counts Summaries {.tabset}
### Subread Assignment Summary
These plots will show the breakdown of read assignment by `featureCounts`.

```{r subread_summary, echo=FALSE, message=FALSE, fig.width=8, fig.height=min(4.8, 0.6*lg_cutoff), results="asis"}
library(knitr)
par(mar=c(4, 3.5, 1, 0.5), mgp=c(2.5, 0.75, 0))
subread_sum <- read.table(paste(params["workdir"], "allsamples", "subread_counts.txt.summary", sep="/"), header=TRUE)
plt_dat <- as.matrix(subread_sum[,-c(1)])
# Combined the unassigned categories into one
plt_dat_comb <- matrix(
    c(plt_dat[1,], as.numeric(apply(plt_dat[-c(1),], 2, sum))),
    byrow=TRUE,
    ncol=nsamp)
colnames(plt_dat_comb) <- NULL
categories <- c("Assigned", "Unassigned")
bar_cols <- c("#1f78b4", "#999999")
maxct <- max(plt_dat_comb)/1000000

if(large_dataset) {
    cat("#### Counts-based Plots {.tabset}\n")
    for(i in unique(chunks)) {
        idx <- which(chunks == i)
        cat("##### Samples ", idx[1], " to ", idx[length(idx)], "\n")
        subdat <- plt_dat_comb[,idx]
        at <- barplot(
            subdat/1000000,
            beside=TRUE,
            col=bar_cols,
            axes=FALSE,
            xlim=c(0, maxct*1.2),
            ylab="",
            xlab="Fragment Count (Millions)",
            main="Subread Summary",
            horiz=TRUE)
        axis(side=2, at=apply(at, 2, mean), labels=colnames(subread_sum[-c(1)])[idx], las=2, cex.axis=0.6, lty=0)
        axis(side=1)
        legend("right", categories, fill=bar_cols, xpd=TRUE)
        cat("\n\n")
    }
} else {
    at <- barplot(
        plt_dat_comb/1000000,
        beside=TRUE,
        col=bar_cols,
        axes=FALSE,
        xlim=c(0, maxct*1.2),
        ylab="",
        xlab="Fragment Count (Millions)",
        main="Subread Summary",
        horiz=TRUE)
    axis(side=2, at=apply(at, 2, mean), labels=colnames(subread_sum[-c(1)]), las=2, cex.axis=0.6, lty=0)
    axis(side=1)
    legend("right", categories, fill=bar_cols, xpd=TRUE)
}
```


```{r subread_summary_prop, echo=FALSE, message=FALSE, fig.height=min(3.6, 0.4*lg_cutoff), results="asis"}
plt_dat_prop <- t(plt_dat_comb)
plt_dat_prop <- plt_dat_prop/rowSums(plt_dat_prop)
plt_dat_prop <- t(plt_dat_prop)
par(mar=c(4, 3.5, 1, 0.5), mgp=c(2.5, 0.75, 0))
if(large_dataset) {
    cat("#### Proportions-based Plots {.tabset}\n")
    for(i in unique(chunks)) {
        idx <- which(chunks == i)
        cat("##### Samples ", idx[1], " to ", idx[length(idx)], "\n")
        subdat <- plt_dat_prop[,idx]
        at <- barplot(
            subdat,
            beside=FALSE,
            col=bar_cols,
            axes=FALSE,
            xlim=c(0, 1.2),
            ylab="",
            xlab="Proportions",
            main="Subread Summary",
            horiz=TRUE)
        axis(side=2, at=at, labels=colnames(subread_sum[-c(1)])[idx], las=2, cex.axis=0.6, lty=0)
        axis(side=1)
        legend("right", categories, fill=bar_cols, xpd=TRUE)
        cat("\n\n")
    }
} else {
    at <- barplot(
        plt_dat_prop,
        beside=FALSE,
        col=bar_cols,
        axes=FALSE,
        xlim=c(0, 1.2),
        ylab="",
        xlab="Proportions",
        main="Subread Summary",
        horiz=TRUE)
    axis(side=2, at=at, labels=colnames(subread_sum[-c(1)]), las=2, cex.axis=0.6, lty=0)
    axis(side=1)
    legend("right", categories, fill=bar_cols, xpd=TRUE)
}

# We want to transpose this table so that it scales vertically with the number
# of samples.
hdr <- as.character(subread_sum$Status)
samples <- colnames(subread_sum)[-c(1)]
t_subread <- as.data.frame(t(subread_sum[,-c(1)]))
rownames(t_subread) <- samples
colnames(t_subread) <- hdr
t_subread
```

### Number of Expressed Features
This plot shows the number of features (genes) that have at least one fragment
mapping to them.

```{r expressed_features, echo=FALSE, message=FALSE, results="asis"}
subread_counts <- read.table(paste(params["workdir"], "allsamples", "subread_counts.txt", sep="/"), header=T, sep="\t", comment.char="#")
subread_counts <- subread_counts[,-c(1:6)]
num_expressed <- as.numeric(apply(subread_counts, 2, function(x) sum(x>0)))
maxexpr <- max(num_expressed)
if(large_dataset) {
    cat("#### Plots {.tabset}\n")
    for(i in unique(chunks)) {
        idx <- which(chunks == i)
        subdat <- num_expressed[idx]
        cat("##### Samples ", idx[1], " to ", idx[length(idx)], "\n")
        at <- barplot(
            subdat,
            ylab="Number of Expressed Features",
            ylim=c(0, maxexpr*1.2),
            col="#1f78b4",
            axes=FALSE)
        axis(side=2)
        axis(side=1, at=at, labels=names(subread_counts)[idx], las=2, cex.axis=0.7)
        cat("\n\n")
    }
} else {
    at <- barplot(
        num_expressed,
        ylab="Number of Expressed Features",
        ylim=c(0, maxexpr*1.2),
        col="#1f78b4",
        axes=FALSE)
    axis(side=2)
    axis(side=1, at=at, labels=names(subread_counts), las=2, cex.axis=0.7)
}
```

### Expression in Counts-per-million
Shown below is a distribution of expression values as log2(1+CPM). CPM (counts-per-million)
is a transformation of raw counts that accounts for the number of fragments
sequenced in the library, like FPKM. It does not account for gene length like
FPKM, however. You can compare CPM values for the same gene across samples,
but do not compare CPM values for different genes in the same sample.

```{r cpm_summary, echo=FALSE, message=FALSE, out.width="750", out.height="750"}
library(knitr)
cpm_plot <- paste(params["outdir"], "Plots", "cpm_plot.pdf", sep="/")
# Include as graphics
include_graphics(cpm_plot)
```

### Sample Clustering Heatmap
We then calculated the variance in CPM values for each gene across the sequenced
samples. The 500 genes with the highest variance in expression were used to
generate the following heatmap:

```{r var_hmp, echo=FALSE, message=FALSE, out.width="750", out.height="750"}
library(knitr)
heatmap_plot <- paste(params["outdir"], "Plots", "high_variance_heatmap.pdf", sep="/")
include_graphics(heatmap_plot)
```

### Multidimensional Scaling Plot
CPM values were then used to generate a multidimensional scaling (MDS) plot,
which functions similarly to a principal components plot:

```{r mds_plot, echo=FALSE, message=FALSE, out.width="750", out.height="750"}
library(knitr)
mds_plot <- paste(params["outdir"], "Plots", "mds_plot.pdf", sep="/")
include_graphics(mds_plot)
```


# DEG Testing
If experimental groups were supplied, we test for differential expression
among them with a quasi-likelihood test (using `glmQLFit` in `edgeR`). We apply
a `0.05` false discovery rate correction to the differential expression tests.
If you did not supply experimental groups, then this section will mostly be
empty.

## Experimental Groups
The following experimental groups were supplied to the pipeline. These are read
out of the samplesheet:

```{r expr_groups, echo=FALSE, message=FALSE}
library(knitr)
sheet_sub <- sheet[,c(1, 2)]
names(sheet_sub) <- c("Sample Name", "Group")
kable(sheet_sub, caption="Experimental groups.")
```

## DEG List
The top differentially expressed genes (DEGs) are given below. Comparisons are
reported as `Group2-Group1`, with `Group2` serving as the numerator for the fold
change calculations. That is, if `logFC` is positive, then the gene has higher
expression in `Group2` than in `Group1`. The files in the `DEGs/` directory
under the output directory follow this naming convention:
`DE_Group2-Group1_list.txt`.

```{r degs, echo=FALSE, message=FALSE, results="asis"}
library(knitr)
degdir <- paste(params["outdir"], "DEGs", sep="/")
if(!dir.exists(degdir)) {
    print("There were no groups defined, so there are no differentially expressed genes.")
} else {
    deg_files <- list.files(degdir, full.names=TRUE)
    if(length(deg_files) == 0) {
        print("There were no groups defined, so there are no differentially expressed genes.")
    } else {
        gene_names <- read.table(paste(params["outdir"], "gene_id_gene_name_map.txt", sep="/"), header=FALSE)
        names(gene_names) <- c("EnsemblID", "GeneName")
        for(i in 1:length(deg_files)) {
            curr_f <- deg_files[i]
            fname <- basename(curr_f)
            gps <- unlist(strsplit(fname, "_"))[2]
            d <- read.table(curr_f, header=TRUE)
            d_g <- merge(d, gene_names, by.x="genes", by.y="EnsemblID")
            d_g <- d_g[order(d_g$FDR),]
            if(nrow(d_g) < 25) {
                lim <- nrow(d_g)
            } else {
                lim <- 25
            }
            print(kable(d_g[1:lim,], caption=paste("Top DEGs at the 0.05 FDR for ", gps, sep="")))
        }
    }
}
```
